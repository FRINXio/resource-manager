// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/net-auto/resourceManager/ent"
	"github.com/net-auto/resourceManager/ent/allocationstrategy"
	"github.com/net-auto/resourceManager/ent/resourcepool"
	"github.com/net-auto/resourceManager/graph/graphql/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	OutputCursor() OutputCursorResolver
	PropertyType() PropertyTypeResolver
	Query() QueryResolver
	Resource() ResourceResolver
	ResourcePool() ResourcePoolResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AllocationStrategy struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Lang        func(childComplexity int) int
		Name        func(childComplexity int) int
		Script      func(childComplexity int) int
	}

	CreateAllocatingPoolPayload struct {
		Pool func(childComplexity int) int
	}

	CreateAllocationStrategyPayload struct {
		Strategy func(childComplexity int) int
	}

	CreateNestedAllocatingPoolPayload struct {
		Pool func(childComplexity int) int
	}

	CreateNestedSetPoolPayload struct {
		Pool func(childComplexity int) int
	}

	CreateNestedSingletonPoolPayload struct {
		Pool func(childComplexity int) int
	}

	CreateResourceTypePayload struct {
		ResourceType func(childComplexity int) int
	}

	CreateSetPoolPayload struct {
		Pool func(childComplexity int) int
	}

	CreateSingletonPoolPayload struct {
		Pool func(childComplexity int) int
	}

	CreateTagPayload struct {
		Tag func(childComplexity int) int
	}

	DeleteAllocationStrategyPayload struct {
		Strategy func(childComplexity int) int
	}

	DeleteResourcePoolPayload struct {
		ResourcePoolID func(childComplexity int) int
	}

	DeleteResourceTypePayload struct {
		ResourceTypeID func(childComplexity int) int
	}

	DeleteTagPayload struct {
		TagID func(childComplexity int) int
	}

	Mutation struct {
		ClaimResource              func(childComplexity int, poolID int, description *string, userInput map[string]interface{}) int
		ClaimResourceWithAltID     func(childComplexity int, poolID int, description *string, userInput map[string]interface{}, alternativeID map[string]interface{}) int
		CreateAllocatingPool       func(childComplexity int, input *model.CreateAllocatingPoolInput) int
		CreateAllocationStrategy   func(childComplexity int, input *model.CreateAllocationStrategyInput) int
		CreateNestedAllocatingPool func(childComplexity int, input model.CreateNestedAllocatingPoolInput) int
		CreateNestedSetPool        func(childComplexity int, input model.CreateNestedSetPoolInput) int
		CreateNestedSingletonPool  func(childComplexity int, input model.CreateNestedSingletonPoolInput) int
		CreateResourceType         func(childComplexity int, input model.CreateResourceTypeInput) int
		CreateSetPool              func(childComplexity int, input model.CreateSetPoolInput) int
		CreateSingletonPool        func(childComplexity int, input *model.CreateSingletonPoolInput) int
		CreateTag                  func(childComplexity int, input model.CreateTagInput) int
		DeleteAllocationStrategy   func(childComplexity int, input *model.DeleteAllocationStrategyInput) int
		DeleteResourcePool         func(childComplexity int, input model.DeleteResourcePoolInput) int
		DeleteResourceType         func(childComplexity int, input model.DeleteResourceTypeInput) int
		DeleteTag                  func(childComplexity int, input model.DeleteTagInput) int
		FreeResource               func(childComplexity int, input map[string]interface{}, poolID int) int
		TagPool                    func(childComplexity int, input model.TagPoolInput) int
		TestAllocationStrategy     func(childComplexity int, allocationStrategyID int, resourcePool model.ResourcePoolInput, currentResources []*model.ResourceInput, userInput map[string]interface{}) int
		UntagPool                  func(childComplexity int, input model.UntagPoolInput) int
		UpdateResourceAltID        func(childComplexity int, input map[string]interface{}, poolID int, alternativeID map[string]interface{}) int
		UpdateResourceTypeName     func(childComplexity int, input model.UpdateResourceTypeNameInput) int
		UpdateTag                  func(childComplexity int, input model.UpdateTagInput) int
	}

	OutputCursor struct {
		ID func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	PoolCapacityPayload struct {
		FreeCapacity     func(childComplexity int) int
		UtilizedCapacity func(childComplexity int) int
	}

	PropertyType struct {
		FloatVal  func(childComplexity int) int
		ID        func(childComplexity int) int
		IntVal    func(childComplexity int) int
		Mandatory func(childComplexity int) int
		Name      func(childComplexity int) int
		StringVal func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	Query struct {
		Node                           func(childComplexity int, id int) int
		QueryAllocationStrategies      func(childComplexity int, byName *string) int
		QueryAllocationStrategy        func(childComplexity int, allocationStrategyID int) int
		QueryEmptyResourcePools        func(childComplexity int, resourceTypeID *int, first *int, last *int, before *ent.Cursor, after *ent.Cursor) int
		QueryLeafResourcePools         func(childComplexity int, resourceTypeID *int, tags *model.TagOr, first *int, last *int, before *ent.Cursor, after *ent.Cursor, filterByResources map[string]interface{}) int
		QueryPoolCapacity              func(childComplexity int, poolID int) int
		QueryPoolTypes                 func(childComplexity int) int
		QueryRecentlyActiveResources   func(childComplexity int, fromDatetime string, toDatetime *string, first *int, last *int, before *string, after *string) int
		QueryRequiredPoolProperties    func(childComplexity int, allocationStrategyName string) int
		QueryResource                  func(childComplexity int, input map[string]interface{}, poolID int) int
		QueryResourcePool              func(childComplexity int, poolID int) int
		QueryResourcePoolHierarchyPath func(childComplexity int, poolID int) int
		QueryResourcePools             func(childComplexity int, resourceTypeID *int, tags *model.TagOr, first *int, last *int, before *ent.Cursor, after *ent.Cursor, filterByResources map[string]interface{}) int
		QueryResourceTypes             func(childComplexity int, byName *string) int
		QueryResources                 func(childComplexity int, poolID int, first *int, last *int, before *string, after *string) int
		QueryResourcesByAltID          func(childComplexity int, input map[string]interface{}, poolID *int, first *int, last *int, before *string, after *string) int
		QueryRootResourcePools         func(childComplexity int, resourceTypeID *int, tags *model.TagOr, first *int, last *int, before *ent.Cursor, after *ent.Cursor, filterByResources map[string]interface{}) int
		QueryTags                      func(childComplexity int) int
		SearchPoolsByTags              func(childComplexity int, tags *model.TagOr, first *int, last *int, before *ent.Cursor, after *ent.Cursor) int
	}

	Resource struct {
		AlternativeID func(childComplexity int) int
		Description   func(childComplexity int) int
		ID            func(childComplexity int) int
		NestedPool    func(childComplexity int) int
		ParentPool    func(childComplexity int) int
		Properties    func(childComplexity int) int
	}

	ResourceConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ResourceEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ResourcePool struct {
		AllocatedResources func(childComplexity int, first *int, last *int, before *string, after *string) int
		AllocationStrategy func(childComplexity int) int
		Capacity           func(childComplexity int) int
		ID                 func(childComplexity int) int
		Name               func(childComplexity int) int
		ParentResource     func(childComplexity int) int
		PoolProperties     func(childComplexity int) int
		PoolType           func(childComplexity int) int
		ResourceType       func(childComplexity int) int
		Resources          func(childComplexity int) int
		Tags               func(childComplexity int) int
	}

	ResourcePoolConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ResourcePoolEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	ResourceType struct {
		ID            func(childComplexity int) int
		Name          func(childComplexity int) int
		Pools         func(childComplexity int) int
		PropertyTypes func(childComplexity int) int
	}

	Tag struct {
		ID    func(childComplexity int) int
		Pools func(childComplexity int) int
		Tag   func(childComplexity int) int
	}

	TagPoolPayload struct {
		Tag func(childComplexity int) int
	}

	UntagPoolPayload struct {
		Tag func(childComplexity int) int
	}

	UpdateResourceTypeNamePayload struct {
		ResourceTypeID func(childComplexity int) int
	}

	UpdateTagPayload struct {
		Tag func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateTag(ctx context.Context, input model.CreateTagInput) (*model.CreateTagPayload, error)
	UpdateTag(ctx context.Context, input model.UpdateTagInput) (*model.UpdateTagPayload, error)
	DeleteTag(ctx context.Context, input model.DeleteTagInput) (*model.DeleteTagPayload, error)
	TagPool(ctx context.Context, input model.TagPoolInput) (*model.TagPoolPayload, error)
	UntagPool(ctx context.Context, input model.UntagPoolInput) (*model.UntagPoolPayload, error)
	CreateAllocationStrategy(ctx context.Context, input *model.CreateAllocationStrategyInput) (*model.CreateAllocationStrategyPayload, error)
	DeleteAllocationStrategy(ctx context.Context, input *model.DeleteAllocationStrategyInput) (*model.DeleteAllocationStrategyPayload, error)
	TestAllocationStrategy(ctx context.Context, allocationStrategyID int, resourcePool model.ResourcePoolInput, currentResources []*model.ResourceInput, userInput map[string]interface{}) (map[string]interface{}, error)
	ClaimResource(ctx context.Context, poolID int, description *string, userInput map[string]interface{}) (*ent.Resource, error)
	ClaimResourceWithAltID(ctx context.Context, poolID int, description *string, userInput map[string]interface{}, alternativeID map[string]interface{}) (*ent.Resource, error)
	FreeResource(ctx context.Context, input map[string]interface{}, poolID int) (string, error)
	CreateSetPool(ctx context.Context, input model.CreateSetPoolInput) (*model.CreateSetPoolPayload, error)
	CreateNestedSetPool(ctx context.Context, input model.CreateNestedSetPoolInput) (*model.CreateNestedSetPoolPayload, error)
	CreateSingletonPool(ctx context.Context, input *model.CreateSingletonPoolInput) (*model.CreateSingletonPoolPayload, error)
	CreateNestedSingletonPool(ctx context.Context, input model.CreateNestedSingletonPoolInput) (*model.CreateNestedSingletonPoolPayload, error)
	CreateAllocatingPool(ctx context.Context, input *model.CreateAllocatingPoolInput) (*model.CreateAllocatingPoolPayload, error)
	CreateNestedAllocatingPool(ctx context.Context, input model.CreateNestedAllocatingPoolInput) (*model.CreateNestedAllocatingPoolPayload, error)
	DeleteResourcePool(ctx context.Context, input model.DeleteResourcePoolInput) (*model.DeleteResourcePoolPayload, error)
	CreateResourceType(ctx context.Context, input model.CreateResourceTypeInput) (*model.CreateResourceTypePayload, error)
	DeleteResourceType(ctx context.Context, input model.DeleteResourceTypeInput) (*model.DeleteResourceTypePayload, error)
	UpdateResourceTypeName(ctx context.Context, input model.UpdateResourceTypeNameInput) (*model.UpdateResourceTypeNamePayload, error)
	UpdateResourceAltID(ctx context.Context, input map[string]interface{}, poolID int, alternativeID map[string]interface{}) (*ent.Resource, error)
}
type OutputCursorResolver interface {
	ID(ctx context.Context, obj *ent.Cursor) (string, error)
}
type PropertyTypeResolver interface {
	Type(ctx context.Context, obj *ent.PropertyType) (string, error)
}
type QueryResolver interface {
	QueryPoolCapacity(ctx context.Context, poolID int) (*model.PoolCapacityPayload, error)
	QueryPoolTypes(ctx context.Context) ([]resourcepool.PoolType, error)
	QueryResource(ctx context.Context, input map[string]interface{}, poolID int) (*ent.Resource, error)
	QueryResources(ctx context.Context, poolID int, first *int, last *int, before *string, after *string) (*ent.ResourceConnection, error)
	QueryResourcesByAltID(ctx context.Context, input map[string]interface{}, poolID *int, first *int, last *int, before *string, after *string) (*ent.ResourceConnection, error)
	QueryAllocationStrategy(ctx context.Context, allocationStrategyID int) (*ent.AllocationStrategy, error)
	QueryAllocationStrategies(ctx context.Context, byName *string) ([]*ent.AllocationStrategy, error)
	QueryResourceTypes(ctx context.Context, byName *string) ([]*ent.ResourceType, error)
	QueryRequiredPoolProperties(ctx context.Context, allocationStrategyName string) ([]*ent.PropertyType, error)
	QueryResourcePool(ctx context.Context, poolID int) (*ent.ResourcePool, error)
	QueryEmptyResourcePools(ctx context.Context, resourceTypeID *int, first *int, last *int, before *ent.Cursor, after *ent.Cursor) (*ent.ResourcePoolConnection, error)
	QueryResourcePools(ctx context.Context, resourceTypeID *int, tags *model.TagOr, first *int, last *int, before *ent.Cursor, after *ent.Cursor, filterByResources map[string]interface{}) (*ent.ResourcePoolConnection, error)
	QueryRecentlyActiveResources(ctx context.Context, fromDatetime string, toDatetime *string, first *int, last *int, before *string, after *string) (*ent.ResourceConnection, error)
	QueryResourcePoolHierarchyPath(ctx context.Context, poolID int) ([]*ent.ResourcePool, error)
	QueryRootResourcePools(ctx context.Context, resourceTypeID *int, tags *model.TagOr, first *int, last *int, before *ent.Cursor, after *ent.Cursor, filterByResources map[string]interface{}) (*ent.ResourcePoolConnection, error)
	QueryLeafResourcePools(ctx context.Context, resourceTypeID *int, tags *model.TagOr, first *int, last *int, before *ent.Cursor, after *ent.Cursor, filterByResources map[string]interface{}) (*ent.ResourcePoolConnection, error)
	SearchPoolsByTags(ctx context.Context, tags *model.TagOr, first *int, last *int, before *ent.Cursor, after *ent.Cursor) (*ent.ResourcePoolConnection, error)
	QueryTags(ctx context.Context) ([]*ent.Tag, error)
	Node(ctx context.Context, id int) (ent.Noder, error)
}
type ResourceResolver interface {
	ParentPool(ctx context.Context, obj *ent.Resource) (*ent.ResourcePool, error)
	Properties(ctx context.Context, obj *ent.Resource) (map[string]interface{}, error)
	AlternativeID(ctx context.Context, obj *ent.Resource) (map[string]interface{}, error)
}
type ResourcePoolResolver interface {
	Capacity(ctx context.Context, obj *ent.ResourcePool) (*model.PoolCapacityPayload, error)

	PoolProperties(ctx context.Context, obj *ent.ResourcePool) (map[string]interface{}, error)

	Resources(ctx context.Context, obj *ent.ResourcePool) ([]*ent.Resource, error)

	AllocatedResources(ctx context.Context, obj *ent.ResourcePool, first *int, last *int, before *string, after *string) (*ent.ResourceConnection, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AllocationStrategy.Description":
		if e.complexity.AllocationStrategy.Description == nil {
			break
		}

		return e.complexity.AllocationStrategy.Description(childComplexity), true

	case "AllocationStrategy.id":
		if e.complexity.AllocationStrategy.ID == nil {
			break
		}

		return e.complexity.AllocationStrategy.ID(childComplexity), true

	case "AllocationStrategy.Lang":
		if e.complexity.AllocationStrategy.Lang == nil {
			break
		}

		return e.complexity.AllocationStrategy.Lang(childComplexity), true

	case "AllocationStrategy.Name":
		if e.complexity.AllocationStrategy.Name == nil {
			break
		}

		return e.complexity.AllocationStrategy.Name(childComplexity), true

	case "AllocationStrategy.Script":
		if e.complexity.AllocationStrategy.Script == nil {
			break
		}

		return e.complexity.AllocationStrategy.Script(childComplexity), true

	case "CreateAllocatingPoolPayload.pool":
		if e.complexity.CreateAllocatingPoolPayload.Pool == nil {
			break
		}

		return e.complexity.CreateAllocatingPoolPayload.Pool(childComplexity), true

	case "CreateAllocationStrategyPayload.strategy":
		if e.complexity.CreateAllocationStrategyPayload.Strategy == nil {
			break
		}

		return e.complexity.CreateAllocationStrategyPayload.Strategy(childComplexity), true

	case "CreateNestedAllocatingPoolPayload.pool":
		if e.complexity.CreateNestedAllocatingPoolPayload.Pool == nil {
			break
		}

		return e.complexity.CreateNestedAllocatingPoolPayload.Pool(childComplexity), true

	case "CreateNestedSetPoolPayload.pool":
		if e.complexity.CreateNestedSetPoolPayload.Pool == nil {
			break
		}

		return e.complexity.CreateNestedSetPoolPayload.Pool(childComplexity), true

	case "CreateNestedSingletonPoolPayload.pool":
		if e.complexity.CreateNestedSingletonPoolPayload.Pool == nil {
			break
		}

		return e.complexity.CreateNestedSingletonPoolPayload.Pool(childComplexity), true

	case "CreateResourceTypePayload.resourceType":
		if e.complexity.CreateResourceTypePayload.ResourceType == nil {
			break
		}

		return e.complexity.CreateResourceTypePayload.ResourceType(childComplexity), true

	case "CreateSetPoolPayload.pool":
		if e.complexity.CreateSetPoolPayload.Pool == nil {
			break
		}

		return e.complexity.CreateSetPoolPayload.Pool(childComplexity), true

	case "CreateSingletonPoolPayload.pool":
		if e.complexity.CreateSingletonPoolPayload.Pool == nil {
			break
		}

		return e.complexity.CreateSingletonPoolPayload.Pool(childComplexity), true

	case "CreateTagPayload.tag":
		if e.complexity.CreateTagPayload.Tag == nil {
			break
		}

		return e.complexity.CreateTagPayload.Tag(childComplexity), true

	case "DeleteAllocationStrategyPayload.strategy":
		if e.complexity.DeleteAllocationStrategyPayload.Strategy == nil {
			break
		}

		return e.complexity.DeleteAllocationStrategyPayload.Strategy(childComplexity), true

	case "DeleteResourcePoolPayload.resourcePoolId":
		if e.complexity.DeleteResourcePoolPayload.ResourcePoolID == nil {
			break
		}

		return e.complexity.DeleteResourcePoolPayload.ResourcePoolID(childComplexity), true

	case "DeleteResourceTypePayload.resourceTypeId":
		if e.complexity.DeleteResourceTypePayload.ResourceTypeID == nil {
			break
		}

		return e.complexity.DeleteResourceTypePayload.ResourceTypeID(childComplexity), true

	case "DeleteTagPayload.tagId":
		if e.complexity.DeleteTagPayload.TagID == nil {
			break
		}

		return e.complexity.DeleteTagPayload.TagID(childComplexity), true

	case "Mutation.ClaimResource":
		if e.complexity.Mutation.ClaimResource == nil {
			break
		}

		args, err := ec.field_Mutation_ClaimResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ClaimResource(childComplexity, args["poolId"].(int), args["description"].(*string), args["userInput"].(map[string]interface{})), true

	case "Mutation.ClaimResourceWithAltId":
		if e.complexity.Mutation.ClaimResourceWithAltID == nil {
			break
		}

		args, err := ec.field_Mutation_ClaimResourceWithAltId_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ClaimResourceWithAltID(childComplexity, args["poolId"].(int), args["description"].(*string), args["userInput"].(map[string]interface{}), args["alternativeId"].(map[string]interface{})), true

	case "Mutation.CreateAllocatingPool":
		if e.complexity.Mutation.CreateAllocatingPool == nil {
			break
		}

		args, err := ec.field_Mutation_CreateAllocatingPool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAllocatingPool(childComplexity, args["input"].(*model.CreateAllocatingPoolInput)), true

	case "Mutation.CreateAllocationStrategy":
		if e.complexity.Mutation.CreateAllocationStrategy == nil {
			break
		}

		args, err := ec.field_Mutation_CreateAllocationStrategy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAllocationStrategy(childComplexity, args["input"].(*model.CreateAllocationStrategyInput)), true

	case "Mutation.CreateNestedAllocatingPool":
		if e.complexity.Mutation.CreateNestedAllocatingPool == nil {
			break
		}

		args, err := ec.field_Mutation_CreateNestedAllocatingPool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateNestedAllocatingPool(childComplexity, args["input"].(model.CreateNestedAllocatingPoolInput)), true

	case "Mutation.CreateNestedSetPool":
		if e.complexity.Mutation.CreateNestedSetPool == nil {
			break
		}

		args, err := ec.field_Mutation_CreateNestedSetPool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateNestedSetPool(childComplexity, args["input"].(model.CreateNestedSetPoolInput)), true

	case "Mutation.CreateNestedSingletonPool":
		if e.complexity.Mutation.CreateNestedSingletonPool == nil {
			break
		}

		args, err := ec.field_Mutation_CreateNestedSingletonPool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateNestedSingletonPool(childComplexity, args["input"].(model.CreateNestedSingletonPoolInput)), true

	case "Mutation.CreateResourceType":
		if e.complexity.Mutation.CreateResourceType == nil {
			break
		}

		args, err := ec.field_Mutation_CreateResourceType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateResourceType(childComplexity, args["input"].(model.CreateResourceTypeInput)), true

	case "Mutation.CreateSetPool":
		if e.complexity.Mutation.CreateSetPool == nil {
			break
		}

		args, err := ec.field_Mutation_CreateSetPool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSetPool(childComplexity, args["input"].(model.CreateSetPoolInput)), true

	case "Mutation.CreateSingletonPool":
		if e.complexity.Mutation.CreateSingletonPool == nil {
			break
		}

		args, err := ec.field_Mutation_CreateSingletonPool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateSingletonPool(childComplexity, args["input"].(*model.CreateSingletonPoolInput)), true

	case "Mutation.CreateTag":
		if e.complexity.Mutation.CreateTag == nil {
			break
		}

		args, err := ec.field_Mutation_CreateTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTag(childComplexity, args["input"].(model.CreateTagInput)), true

	case "Mutation.DeleteAllocationStrategy":
		if e.complexity.Mutation.DeleteAllocationStrategy == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteAllocationStrategy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteAllocationStrategy(childComplexity, args["input"].(*model.DeleteAllocationStrategyInput)), true

	case "Mutation.DeleteResourcePool":
		if e.complexity.Mutation.DeleteResourcePool == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteResourcePool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteResourcePool(childComplexity, args["input"].(model.DeleteResourcePoolInput)), true

	case "Mutation.DeleteResourceType":
		if e.complexity.Mutation.DeleteResourceType == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteResourceType_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteResourceType(childComplexity, args["input"].(model.DeleteResourceTypeInput)), true

	case "Mutation.DeleteTag":
		if e.complexity.Mutation.DeleteTag == nil {
			break
		}

		args, err := ec.field_Mutation_DeleteTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTag(childComplexity, args["input"].(model.DeleteTagInput)), true

	case "Mutation.FreeResource":
		if e.complexity.Mutation.FreeResource == nil {
			break
		}

		args, err := ec.field_Mutation_FreeResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FreeResource(childComplexity, args["input"].(map[string]interface{}), args["poolId"].(int)), true

	case "Mutation.TagPool":
		if e.complexity.Mutation.TagPool == nil {
			break
		}

		args, err := ec.field_Mutation_TagPool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TagPool(childComplexity, args["input"].(model.TagPoolInput)), true

	case "Mutation.TestAllocationStrategy":
		if e.complexity.Mutation.TestAllocationStrategy == nil {
			break
		}

		args, err := ec.field_Mutation_TestAllocationStrategy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.TestAllocationStrategy(childComplexity, args["allocationStrategyId"].(int), args["resourcePool"].(model.ResourcePoolInput), args["currentResources"].([]*model.ResourceInput), args["userInput"].(map[string]interface{})), true

	case "Mutation.UntagPool":
		if e.complexity.Mutation.UntagPool == nil {
			break
		}

		args, err := ec.field_Mutation_UntagPool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UntagPool(childComplexity, args["input"].(model.UntagPoolInput)), true

	case "Mutation.UpdateResourceAltId":
		if e.complexity.Mutation.UpdateResourceAltID == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateResourceAltId_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateResourceAltID(childComplexity, args["input"].(map[string]interface{}), args["poolId"].(int), args["alternativeId"].(map[string]interface{})), true

	case "Mutation.UpdateResourceTypeName":
		if e.complexity.Mutation.UpdateResourceTypeName == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateResourceTypeName_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateResourceTypeName(childComplexity, args["input"].(model.UpdateResourceTypeNameInput)), true

	case "Mutation.UpdateTag":
		if e.complexity.Mutation.UpdateTag == nil {
			break
		}

		args, err := ec.field_Mutation_UpdateTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTag(childComplexity, args["input"].(model.UpdateTagInput)), true

	case "OutputCursor.ID":
		if e.complexity.OutputCursor.ID == nil {
			break
		}

		return e.complexity.OutputCursor.ID(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "PoolCapacityPayload.freeCapacity":
		if e.complexity.PoolCapacityPayload.FreeCapacity == nil {
			break
		}

		return e.complexity.PoolCapacityPayload.FreeCapacity(childComplexity), true

	case "PoolCapacityPayload.utilizedCapacity":
		if e.complexity.PoolCapacityPayload.UtilizedCapacity == nil {
			break
		}

		return e.complexity.PoolCapacityPayload.UtilizedCapacity(childComplexity), true

	case "PropertyType.FloatVal":
		if e.complexity.PropertyType.FloatVal == nil {
			break
		}

		return e.complexity.PropertyType.FloatVal(childComplexity), true

	case "PropertyType.id":
		if e.complexity.PropertyType.ID == nil {
			break
		}

		return e.complexity.PropertyType.ID(childComplexity), true

	case "PropertyType.IntVal":
		if e.complexity.PropertyType.IntVal == nil {
			break
		}

		return e.complexity.PropertyType.IntVal(childComplexity), true

	case "PropertyType.Mandatory":
		if e.complexity.PropertyType.Mandatory == nil {
			break
		}

		return e.complexity.PropertyType.Mandatory(childComplexity), true

	case "PropertyType.Name":
		if e.complexity.PropertyType.Name == nil {
			break
		}

		return e.complexity.PropertyType.Name(childComplexity), true

	case "PropertyType.StringVal":
		if e.complexity.PropertyType.StringVal == nil {
			break
		}

		return e.complexity.PropertyType.StringVal(childComplexity), true

	case "PropertyType.Type":
		if e.complexity.PropertyType.Type == nil {
			break
		}

		return e.complexity.PropertyType.Type(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(int)), true

	case "Query.QueryAllocationStrategies":
		if e.complexity.Query.QueryAllocationStrategies == nil {
			break
		}

		args, err := ec.field_Query_QueryAllocationStrategies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryAllocationStrategies(childComplexity, args["byName"].(*string)), true

	case "Query.QueryAllocationStrategy":
		if e.complexity.Query.QueryAllocationStrategy == nil {
			break
		}

		args, err := ec.field_Query_QueryAllocationStrategy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryAllocationStrategy(childComplexity, args["allocationStrategyId"].(int)), true

	case "Query.QueryEmptyResourcePools":
		if e.complexity.Query.QueryEmptyResourcePools == nil {
			break
		}

		args, err := ec.field_Query_QueryEmptyResourcePools_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryEmptyResourcePools(childComplexity, args["resourceTypeId"].(*int), args["first"].(*int), args["last"].(*int), args["before"].(*ent.Cursor), args["after"].(*ent.Cursor)), true

	case "Query.QueryLeafResourcePools":
		if e.complexity.Query.QueryLeafResourcePools == nil {
			break
		}

		args, err := ec.field_Query_QueryLeafResourcePools_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryLeafResourcePools(childComplexity, args["resourceTypeId"].(*int), args["tags"].(*model.TagOr), args["first"].(*int), args["last"].(*int), args["before"].(*ent.Cursor), args["after"].(*ent.Cursor), args["filterByResources"].(map[string]interface{})), true

	case "Query.QueryPoolCapacity":
		if e.complexity.Query.QueryPoolCapacity == nil {
			break
		}

		args, err := ec.field_Query_QueryPoolCapacity_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryPoolCapacity(childComplexity, args["poolId"].(int)), true

	case "Query.QueryPoolTypes":
		if e.complexity.Query.QueryPoolTypes == nil {
			break
		}

		return e.complexity.Query.QueryPoolTypes(childComplexity), true

	case "Query.QueryRecentlyActiveResources":
		if e.complexity.Query.QueryRecentlyActiveResources == nil {
			break
		}

		args, err := ec.field_Query_QueryRecentlyActiveResources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryRecentlyActiveResources(childComplexity, args["fromDatetime"].(string), args["toDatetime"].(*string), args["first"].(*int), args["last"].(*int), args["before"].(*string), args["after"].(*string)), true

	case "Query.QueryRequiredPoolProperties":
		if e.complexity.Query.QueryRequiredPoolProperties == nil {
			break
		}

		args, err := ec.field_Query_QueryRequiredPoolProperties_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryRequiredPoolProperties(childComplexity, args["allocationStrategyName"].(string)), true

	case "Query.QueryResource":
		if e.complexity.Query.QueryResource == nil {
			break
		}

		args, err := ec.field_Query_QueryResource_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryResource(childComplexity, args["input"].(map[string]interface{}), args["poolId"].(int)), true

	case "Query.QueryResourcePool":
		if e.complexity.Query.QueryResourcePool == nil {
			break
		}

		args, err := ec.field_Query_QueryResourcePool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryResourcePool(childComplexity, args["poolId"].(int)), true

	case "Query.QueryResourcePoolHierarchyPath":
		if e.complexity.Query.QueryResourcePoolHierarchyPath == nil {
			break
		}

		args, err := ec.field_Query_QueryResourcePoolHierarchyPath_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryResourcePoolHierarchyPath(childComplexity, args["poolId"].(int)), true

	case "Query.QueryResourcePools":
		if e.complexity.Query.QueryResourcePools == nil {
			break
		}

		args, err := ec.field_Query_QueryResourcePools_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryResourcePools(childComplexity, args["resourceTypeId"].(*int), args["tags"].(*model.TagOr), args["first"].(*int), args["last"].(*int), args["before"].(*ent.Cursor), args["after"].(*ent.Cursor), args["filterByResources"].(map[string]interface{})), true

	case "Query.QueryResourceTypes":
		if e.complexity.Query.QueryResourceTypes == nil {
			break
		}

		args, err := ec.field_Query_QueryResourceTypes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryResourceTypes(childComplexity, args["byName"].(*string)), true

	case "Query.QueryResources":
		if e.complexity.Query.QueryResources == nil {
			break
		}

		args, err := ec.field_Query_QueryResources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryResources(childComplexity, args["poolId"].(int), args["first"].(*int), args["last"].(*int), args["before"].(*string), args["after"].(*string)), true

	case "Query.QueryResourcesByAltId":
		if e.complexity.Query.QueryResourcesByAltID == nil {
			break
		}

		args, err := ec.field_Query_QueryResourcesByAltId_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryResourcesByAltID(childComplexity, args["input"].(map[string]interface{}), args["poolId"].(*int), args["first"].(*int), args["last"].(*int), args["before"].(*string), args["after"].(*string)), true

	case "Query.QueryRootResourcePools":
		if e.complexity.Query.QueryRootResourcePools == nil {
			break
		}

		args, err := ec.field_Query_QueryRootResourcePools_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.QueryRootResourcePools(childComplexity, args["resourceTypeId"].(*int), args["tags"].(*model.TagOr), args["first"].(*int), args["last"].(*int), args["before"].(*ent.Cursor), args["after"].(*ent.Cursor), args["filterByResources"].(map[string]interface{})), true

	case "Query.QueryTags":
		if e.complexity.Query.QueryTags == nil {
			break
		}

		return e.complexity.Query.QueryTags(childComplexity), true

	case "Query.SearchPoolsByTags":
		if e.complexity.Query.SearchPoolsByTags == nil {
			break
		}

		args, err := ec.field_Query_SearchPoolsByTags_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchPoolsByTags(childComplexity, args["tags"].(*model.TagOr), args["first"].(*int), args["last"].(*int), args["before"].(*ent.Cursor), args["after"].(*ent.Cursor)), true

	case "Resource.AlternativeId":
		if e.complexity.Resource.AlternativeID == nil {
			break
		}

		return e.complexity.Resource.AlternativeID(childComplexity), true

	case "Resource.Description":
		if e.complexity.Resource.Description == nil {
			break
		}

		return e.complexity.Resource.Description(childComplexity), true

	case "Resource.id":
		if e.complexity.Resource.ID == nil {
			break
		}

		return e.complexity.Resource.ID(childComplexity), true

	case "Resource.NestedPool":
		if e.complexity.Resource.NestedPool == nil {
			break
		}

		return e.complexity.Resource.NestedPool(childComplexity), true

	case "Resource.ParentPool":
		if e.complexity.Resource.ParentPool == nil {
			break
		}

		return e.complexity.Resource.ParentPool(childComplexity), true

	case "Resource.Properties":
		if e.complexity.Resource.Properties == nil {
			break
		}

		return e.complexity.Resource.Properties(childComplexity), true

	case "ResourceConnection.edges":
		if e.complexity.ResourceConnection.Edges == nil {
			break
		}

		return e.complexity.ResourceConnection.Edges(childComplexity), true

	case "ResourceConnection.pageInfo":
		if e.complexity.ResourceConnection.PageInfo == nil {
			break
		}

		return e.complexity.ResourceConnection.PageInfo(childComplexity), true

	case "ResourceConnection.totalCount":
		if e.complexity.ResourceConnection.TotalCount == nil {
			break
		}

		return e.complexity.ResourceConnection.TotalCount(childComplexity), true

	case "ResourceEdge.cursor":
		if e.complexity.ResourceEdge.Cursor == nil {
			break
		}

		return e.complexity.ResourceEdge.Cursor(childComplexity), true

	case "ResourceEdge.node":
		if e.complexity.ResourceEdge.Node == nil {
			break
		}

		return e.complexity.ResourceEdge.Node(childComplexity), true

	case "ResourcePool.allocatedResources":
		if e.complexity.ResourcePool.AllocatedResources == nil {
			break
		}

		args, err := ec.field_ResourcePool_allocatedResources_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ResourcePool.AllocatedResources(childComplexity, args["first"].(*int), args["last"].(*int), args["before"].(*string), args["after"].(*string)), true

	case "ResourcePool.AllocationStrategy":
		if e.complexity.ResourcePool.AllocationStrategy == nil {
			break
		}

		return e.complexity.ResourcePool.AllocationStrategy(childComplexity), true

	case "ResourcePool.Capacity":
		if e.complexity.ResourcePool.Capacity == nil {
			break
		}

		return e.complexity.ResourcePool.Capacity(childComplexity), true

	case "ResourcePool.id":
		if e.complexity.ResourcePool.ID == nil {
			break
		}

		return e.complexity.ResourcePool.ID(childComplexity), true

	case "ResourcePool.Name":
		if e.complexity.ResourcePool.Name == nil {
			break
		}

		return e.complexity.ResourcePool.Name(childComplexity), true

	case "ResourcePool.ParentResource":
		if e.complexity.ResourcePool.ParentResource == nil {
			break
		}

		return e.complexity.ResourcePool.ParentResource(childComplexity), true

	case "ResourcePool.PoolProperties":
		if e.complexity.ResourcePool.PoolProperties == nil {
			break
		}

		return e.complexity.ResourcePool.PoolProperties(childComplexity), true

	case "ResourcePool.PoolType":
		if e.complexity.ResourcePool.PoolType == nil {
			break
		}

		return e.complexity.ResourcePool.PoolType(childComplexity), true

	case "ResourcePool.ResourceType":
		if e.complexity.ResourcePool.ResourceType == nil {
			break
		}

		return e.complexity.ResourcePool.ResourceType(childComplexity), true

	case "ResourcePool.Resources":
		if e.complexity.ResourcePool.Resources == nil {
			break
		}

		return e.complexity.ResourcePool.Resources(childComplexity), true

	case "ResourcePool.Tags":
		if e.complexity.ResourcePool.Tags == nil {
			break
		}

		return e.complexity.ResourcePool.Tags(childComplexity), true

	case "ResourcePoolConnection.edges":
		if e.complexity.ResourcePoolConnection.Edges == nil {
			break
		}

		return e.complexity.ResourcePoolConnection.Edges(childComplexity), true

	case "ResourcePoolConnection.pageInfo":
		if e.complexity.ResourcePoolConnection.PageInfo == nil {
			break
		}

		return e.complexity.ResourcePoolConnection.PageInfo(childComplexity), true

	case "ResourcePoolConnection.totalCount":
		if e.complexity.ResourcePoolConnection.TotalCount == nil {
			break
		}

		return e.complexity.ResourcePoolConnection.TotalCount(childComplexity), true

	case "ResourcePoolEdge.cursor":
		if e.complexity.ResourcePoolEdge.Cursor == nil {
			break
		}

		return e.complexity.ResourcePoolEdge.Cursor(childComplexity), true

	case "ResourcePoolEdge.node":
		if e.complexity.ResourcePoolEdge.Node == nil {
			break
		}

		return e.complexity.ResourcePoolEdge.Node(childComplexity), true

	case "ResourceType.id":
		if e.complexity.ResourceType.ID == nil {
			break
		}

		return e.complexity.ResourceType.ID(childComplexity), true

	case "ResourceType.Name":
		if e.complexity.ResourceType.Name == nil {
			break
		}

		return e.complexity.ResourceType.Name(childComplexity), true

	case "ResourceType.Pools":
		if e.complexity.ResourceType.Pools == nil {
			break
		}

		return e.complexity.ResourceType.Pools(childComplexity), true

	case "ResourceType.PropertyTypes":
		if e.complexity.ResourceType.PropertyTypes == nil {
			break
		}

		return e.complexity.ResourceType.PropertyTypes(childComplexity), true

	case "Tag.id":
		if e.complexity.Tag.ID == nil {
			break
		}

		return e.complexity.Tag.ID(childComplexity), true

	case "Tag.Pools":
		if e.complexity.Tag.Pools == nil {
			break
		}

		return e.complexity.Tag.Pools(childComplexity), true

	case "Tag.Tag":
		if e.complexity.Tag.Tag == nil {
			break
		}

		return e.complexity.Tag.Tag(childComplexity), true

	case "TagPoolPayload.tag":
		if e.complexity.TagPoolPayload.Tag == nil {
			break
		}

		return e.complexity.TagPoolPayload.Tag(childComplexity), true

	case "UntagPoolPayload.tag":
		if e.complexity.UntagPoolPayload.Tag == nil {
			break
		}

		return e.complexity.UntagPoolPayload.Tag(childComplexity), true

	case "UpdateResourceTypeNamePayload.resourceTypeId":
		if e.complexity.UpdateResourceTypeNamePayload.ResourceTypeID == nil {
			break
		}

		return e.complexity.UpdateResourceTypeNamePayload.ResourceTypeID(childComplexity), true

	case "UpdateTagPayload.tag":
		if e.complexity.UpdateTagPayload.Tag == nil {
			break
		}

		return e.complexity.UpdateTagPayload.Tag(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateAllocatingPoolInput,
		ec.unmarshalInputCreateAllocationStrategyInput,
		ec.unmarshalInputCreateNestedAllocatingPoolInput,
		ec.unmarshalInputCreateNestedSetPoolInput,
		ec.unmarshalInputCreateNestedSingletonPoolInput,
		ec.unmarshalInputCreateResourceTypeInput,
		ec.unmarshalInputCreateSetPoolInput,
		ec.unmarshalInputCreateSingletonPoolInput,
		ec.unmarshalInputCreateTagInput,
		ec.unmarshalInputDeleteAllocationStrategyInput,
		ec.unmarshalInputDeleteResourcePoolInput,
		ec.unmarshalInputDeleteResourceTypeInput,
		ec.unmarshalInputDeleteTagInput,
		ec.unmarshalInputResourceInput,
		ec.unmarshalInputResourcePoolInput,
		ec.unmarshalInputTagAnd,
		ec.unmarshalInputTagOr,
		ec.unmarshalInputTagPoolInput,
		ec.unmarshalInputUntagPoolInput,
		ec.unmarshalInputUpdateResourceTypeNameInput,
		ec.unmarshalInputUpdateTagInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/schema.graphql", Input: `directive @goModel(
  model: String
  models: [String!]
) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION

"""
Interface for entities needed by the relay-framework
"""
interface Node
  @goModel(model: "github.com/net-auto/resourceManager/ent.Noder") {
  """
  The ID of the entity
  """
  id: ID!
}

"""
Describes the properties of a resource
"""
type ResourceType implements Node
  @goModel(model: "github.com/net-auto/resourceManager/ent.ResourceType") {
  Name: String!
  Pools: [ResourcePool!]!
  PropertyTypes: [PropertyType!]!
  id: ID!
}

"""
Defines the type of the property
"""
type PropertyType implements Node
  @goModel(model: "github.com/net-auto/resourceManager/ent.PropertyType") {
  FloatVal: Float
  IntVal: Int
  Mandatory: Boolean
  StringVal: String
  Name: String!
  Type: String!
  id: ID!
}

"""
Holds the string value for pagination
"""
type OutputCursor
  @goModel(model: "github.com/net-auto/resourceManager/ent.Cursor") {
  ID: String!
}

scalar Cursor @goModel(model: "github.com/net-auto/resourceManager/ent.Cursor")

"""
Holds information about the requested pagination page
"""
type PageInfo
  @goModel(model: "github.com/net-auto/resourceManager/ent.PageInfo") {
  endCursor: OutputCursor
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: OutputCursor
}

"""
A Relay-specific entity that holds information about the requested pagination page
"""
type ResourceEdge
  @goModel(model: "github.com/net-auto/resourceManager/ent.ResourceEdge") {
  cursor: OutputCursor!
  node: Resource!
}

"""
A Relay-specific entity holding information about pagination
"""
type ResourceConnection
  @goModel(
    model: "github.com/net-auto/resourceManager/ent.ResourceConnection"
  ) {
  edges: [ResourceEdge]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ResourcePoolEdge
  @goModel(model: "github.com/net-auto/resourceManager/ent.ResourcePoolEdge") {
  cursor: OutputCursor!
  node: ResourcePool!
}

type ResourcePoolConnection
  @goModel(
    model: "github.com/net-auto/resourceManager/ent.ResourcePoolConnection"
  ) {
  edges: [ResourcePoolEdge]!
  pageInfo: PageInfo!
  totalCount: Int!
}

"""
A pool is an entity that contains allocated and free resources
"""
type ResourcePool implements Node
  @goModel(model: "github.com/net-auto/resourceManager/ent.ResourcePool") {
  AllocationStrategy: AllocationStrategy
  Capacity: PoolCapacityPayload
  Name: String!
  ParentResource: Resource
  PoolProperties: Map!
  PoolType: PoolType!
  ResourceType: ResourceType!
  Resources: [Resource!]!
  Tags: [Tag!]!
  allocatedResources(
    first: Int
    last: Int
    before: String
    after: String
  ): ResourceConnection
  id: ID!
}

"""
Defines the type of pool
"""
enum PoolType
  @goModel(
    model: "github.com/net-auto/resourceManager/ent/resourcepool.PoolType"
  ) {
  allocating
  set
  singleton
}

"""
Represents data-type where variable keys and values can be used
"""
scalar Map

"""
Represents an allocated resource
"""
type Resource implements Node
  @goModel(model: "github.com/net-auto/resourceManager/ent.Resource") {
  Description: String
  NestedPool: ResourcePool
  ParentPool: ResourcePool!
  Properties: Map!
  AlternativeId: Map
  id: ID!
}

"""
Supported languages for allocation strategy scripts
"""
enum AllocationStrategyLang
  @goModel(
    model: "github.com/net-auto/resourceManager/ent/allocationstrategy.Lang"
  ) {
  js
  py
}

"""
Represents an allocation strategy
"""
type AllocationStrategy implements Node
  @goModel(
    model: "github.com/net-auto/resourceManager/ent.AllocationStrategy"
  ) {
  Description: String
  Lang: AllocationStrategyLang!
  Name: String!
  Script: String!
  id: ID!
}

"""
Pools can be tagged for easier search
"""
type Tag implements Node
  @goModel(model: "github.com/net-auto/resourceManager/ent.Tag") {
  Pools: [ResourcePool]
  Tag: String!
  id: ID!
}

"""
Helper entities for tag search
"""
input TagAnd {
  matchesAll: [String!]!
}

"""
Helper entities for tag search
"""
input TagOr {
  matchesAny: [TagAnd!]!
}

"""
Convenience entity representing the identity of a pool in some calls
"""
input ResourcePoolInput {
  ResourcePoolID: ID!
  ResourcePoolName: String!
  poolProperties: Map!
}

"""
Alternative representation of identity of a resource (i.e. alternative to resource ID)
"""
input ResourceInput {
  Properties: Map!
  # TODO replace with enum
  Status: String!
  UpdatedAt: String!
}

"""
Input parameters for creating a set pool
"""
input CreateSetPoolInput {
  description: String
  poolDealocationSafetyPeriod: Int!
  poolName: String!
  poolValues: [Map!]!
  resourceTypeId: ID!
  tags: [String!]
}

"""
Output of creating set pool
"""
type CreateSetPoolPayload {
  pool: ResourcePool
}

"""
Input parameters for creating a nested set pool
"""
input CreateNestedSetPoolInput {
  description: String
  parentResourceId: ID!
  poolDealocationSafetyPeriod: Int!
  poolName: String!
  poolValues: [Map]!
  resourceTypeId: ID!
  tags: [String!]
}

"""
Output of creating a nested set pool
"""
type CreateNestedSetPoolPayload {
  pool: ResourcePool
}

"""
Input parameters for creating a nested singleton pool
"""
input CreateNestedSingletonPoolInput {
  description: String
  parentResourceId: ID!
  poolName: String!
  poolValues: [Map]!
  resourceTypeId: ID!
  tags: [String!]
}

"""
Output of creating a nested singleton pool
"""
type CreateNestedSingletonPoolPayload {
  pool: ResourcePool
}

"""
Input entity for deleting a pool
"""
input DeleteResourcePoolInput {
  resourcePoolId: ID!
}

"""
Output entity for deleting a pool
"""
type DeleteResourcePoolPayload {
  resourcePoolId: ID!
}

"""
Input parameters for creating a singleton pool
"""
input CreateSingletonPoolInput {
  description: String
  poolName: String!
  poolValues: [Map!]!
  resourceTypeId: ID!
  tags: [String!]
}

"""
Output of creating a singleton pool
"""
type CreateSingletonPoolPayload {
  pool: ResourcePool
}

"""
Input parameters for creating an allocation pool
"""
input CreateAllocatingPoolInput {
  allocationStrategyId: ID!
  description: String
  poolDealocationSafetyPeriod: Int!
  poolName: String!
  poolProperties: Map!
  poolPropertyTypes: Map!
  resourceTypeId: ID!
  tags: [String!]
}

"""
Output of creating an allocating pool
"""
type CreateAllocatingPoolPayload {
  pool: ResourcePool
}

"""
Input parameters for creating a nested allocation pool
"""
input CreateNestedAllocatingPoolInput {
  allocationStrategyId: ID!
  description: String
  parentResourceId: ID!
  poolDealocationSafetyPeriod: Int!
  poolName: String!
  resourceTypeId: ID!
  tags: [String!]
}

"""
Output of creating a nested allocating pool
"""
type CreateNestedAllocatingPoolPayload {
  pool: ResourcePool
}

"""
Entity representing capacity of a pool
"""
type PoolCapacityPayload {
  freeCapacity: String!
  utilizedCapacity: String!
}

type Query {
  # Deprecated, use capacity object inside the Resource pool
  QueryPoolCapacity(poolId: ID!): PoolCapacityPayload!
  QueryPoolTypes: [PoolType!]!
  QueryResource(input: Map!, poolId: ID!): Resource!
  QueryResources(
    poolId: ID!
    first: Int
    last: Int
    before: String
    after: String
  ): ResourceConnection!
  QueryResourcesByAltId(
    input: Map!
    poolId: ID
    first: Int
    last: Int
    before: String
    after: String
  ): ResourceConnection!
  QueryAllocationStrategy(allocationStrategyId: ID!): AllocationStrategy!
  QueryAllocationStrategies(byName: String): [AllocationStrategy!]!
  QueryResourceTypes(byName: String): [ResourceType!]!
  QueryRequiredPoolProperties(allocationStrategyName: String!): [PropertyType!]!

  QueryResourcePool(poolId: ID!): ResourcePool!

  QueryEmptyResourcePools(resourceTypeId: ID, first: Int, last: Int, before: Cursor, after: Cursor): ResourcePoolConnection!
  QueryResourcePools(
    resourceTypeId: ID
    tags: TagOr
    first: Int
    last: Int
    before: Cursor
    after: Cursor
    filterByResources: Map
  ): ResourcePoolConnection!
  QueryRecentlyActiveResources(
    fromDatetime: String!
    toDatetime: String
    first: Int
    last: Int
    before: String
    after: String
  ): ResourceConnection!
  QueryResourcePoolHierarchyPath(poolId: ID!): [ResourcePool!]!
  QueryRootResourcePools(resourceTypeId: ID, tags: TagOr, first: Int, last: Int, before: Cursor, after: Cursor, filterByResources: Map): ResourcePoolConnection!
  QueryLeafResourcePools(resourceTypeId: ID, tags: TagOr, first: Int, last: Int, before: Cursor, after: Cursor, filterByResources: Map): ResourcePoolConnection!
  SearchPoolsByTags(tags: TagOr, first: Int, last: Int, before: Cursor, after: Cursor): ResourcePoolConnection!

  QueryTags: [Tag!]!
  node(id: ID!): Node
}

"""
Input parameters for creating a new tag
"""
input CreateTagInput {
  tagText: String!
}

"""
Output of creating a tag
"""
type CreateTagPayload {
  tag: Tag
}

"""
Input parameters for updating an existing tag
"""
input UpdateTagInput {
  tagId: ID!
  tagText: String!
}

"""
Output of updating a tag
"""
type UpdateTagPayload {
  tag: Tag
}

"""
Input parameters for deleting an existing tag
"""
input DeleteTagInput {
  tagId: ID!
}

"""
Output of deleting a tag
"""
type DeleteTagPayload {
  tagId: ID!
}

"""
Input parameters for a call adding a tag to pool
"""
input TagPoolInput {
  tagId: ID!
  poolId: ID!
}

"""
Output of adding a specific tag to a pool
"""
type TagPoolPayload {
  tag: Tag
}

"""
Input parameters for a call removing a tag from pool
"""
input UntagPoolInput {
  tagId: ID!
  poolId: ID!
}

"""
Output of removing a specific tag from a pool
"""
type UntagPoolPayload {
  tag: Tag
}

"""
Input parameters for creating a new allocation strategy
"""
input CreateAllocationStrategyInput {
  name: String!
  description: String
  script: String!
  lang: AllocationStrategyLang!
  expectedPoolPropertyTypes: Map
}

"""
Output of creating a new allocation strategy
"""
type CreateAllocationStrategyPayload {
  strategy: AllocationStrategy
}

"""
Input parameters for deleting an existing allocation strategy
"""
input DeleteAllocationStrategyInput {
  allocationStrategyId: ID!
}

"""
Output of deleting an existing allocation strategy
"""
type DeleteAllocationStrategyPayload {
  strategy: AllocationStrategy
}

"""
Creating a new resource-type
"""
input CreateResourceTypeInput {
  """
  name of the resource type AND property type (should they be different?)
  """
  resourceName: String!
  """
  resourceProperties: Map! - for key "init" the value is the initial value of the property type (like 7)
                           - for key "type" the value is the name of the type like "int"
  """
  resourceProperties: Map!
}

"""
Output of creating a new resource-type
"""
type CreateResourceTypePayload {
  resourceType: ResourceType!
}

"""
Input parameters for deleting an existing resource-type
"""
input DeleteResourceTypeInput {
  resourceTypeId: ID!
}

"""
Output of deleting a resource-type
"""
type DeleteResourceTypePayload {
  resourceTypeId: ID!
}

"""
Input parameters updating the name of a resource-type
"""
input UpdateResourceTypeNameInput {
  resourceTypeId: ID!
  resourceName: String!
}

"""
Output of updating the name of a resource-type
"""
type UpdateResourceTypeNamePayload {
  resourceTypeId: ID!
}

type Mutation {
  # Tagging
  CreateTag(input: CreateTagInput!): CreateTagPayload!
  UpdateTag(input: UpdateTagInput!): UpdateTagPayload!
  DeleteTag(input: DeleteTagInput!): DeleteTagPayload!
  TagPool(input: TagPoolInput!): TagPoolPayload!
  UntagPool(input: UntagPoolInput!): UntagPoolPayload!

  # Allocation strategy
  CreateAllocationStrategy(
    input: CreateAllocationStrategyInput
  ): CreateAllocationStrategyPayload!
  DeleteAllocationStrategy(
    input: DeleteAllocationStrategyInput
  ): DeleteAllocationStrategyPayload!
  TestAllocationStrategy(
    allocationStrategyId: ID!
    resourcePool: ResourcePoolInput!
    currentResources: [ResourceInput!]!
    userInput: Map!
  ): Map!

  # managing resources via pools
  ClaimResource(poolId: ID!, description: String, userInput: Map!): Resource!
  ClaimResourceWithAltId(
    poolId: ID!
    description: String
    userInput: Map!
    alternativeId: Map!
  ): Resource!
  FreeResource(input: Map!, poolId: ID!): String!

  # create/update/delete resource pool
  CreateSetPool(input: CreateSetPoolInput!): CreateSetPoolPayload!
  CreateNestedSetPool(
    input: CreateNestedSetPoolInput!
  ): CreateNestedSetPoolPayload!
  CreateSingletonPool(
    input: CreateSingletonPoolInput
  ): CreateSingletonPoolPayload!
  CreateNestedSingletonPool(
    input: CreateNestedSingletonPoolInput!
  ): CreateNestedSingletonPoolPayload!
  CreateAllocatingPool(
    input: CreateAllocatingPoolInput
  ): CreateAllocatingPoolPayload!
  CreateNestedAllocatingPool(
    input: CreateNestedAllocatingPoolInput!
  ): CreateNestedAllocatingPoolPayload!
  DeleteResourcePool(
    input: DeleteResourcePoolInput!
  ): DeleteResourcePoolPayload!

  # create/update/delete resource type
  CreateResourceType(
    input: CreateResourceTypeInput!
  ): CreateResourceTypePayload!
  DeleteResourceType(
    input: DeleteResourceTypeInput!
  ): DeleteResourceTypePayload!
  ## it only changes the name of the resource type
  UpdateResourceTypeName(
    input: UpdateResourceTypeNameInput!
  ): UpdateResourceTypeNamePayload!

  # update resource alternative id
  UpdateResourceAltId(input: Map!, poolId: ID!, alternativeId: Map!): Resource!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_ClaimResourceWithAltId_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["poolId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolId"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["poolId"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["description"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["description"] = arg1
	var arg2 map[string]interface{}
	if tmp, ok := rawArgs["userInput"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userInput"))
		arg2, err = ec.unmarshalNMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userInput"] = arg2
	var arg3 map[string]interface{}
	if tmp, ok := rawArgs["alternativeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alternativeId"))
		arg3, err = ec.unmarshalNMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["alternativeId"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_ClaimResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["poolId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolId"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["poolId"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["description"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["description"] = arg1
	var arg2 map[string]interface{}
	if tmp, ok := rawArgs["userInput"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userInput"))
		arg2, err = ec.unmarshalNMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userInput"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_CreateAllocatingPool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.CreateAllocatingPoolInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOCreateAllocatingPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateAllocatingPoolInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_CreateAllocationStrategy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.CreateAllocationStrategyInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOCreateAllocationStrategyInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateAllocationStrategyInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_CreateNestedAllocatingPool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateNestedAllocatingPoolInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateNestedAllocatingPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedAllocatingPoolInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_CreateNestedSetPool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateNestedSetPoolInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateNestedSetPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedSetPoolInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_CreateNestedSingletonPool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateNestedSingletonPoolInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateNestedSingletonPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedSingletonPoolInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_CreateResourceType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateResourceTypeInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateResourceTypeInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateResourceTypeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_CreateSetPool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateSetPoolInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateSetPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateSetPoolInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_CreateSingletonPool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.CreateSingletonPoolInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOCreateSingletonPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateSingletonPoolInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_CreateTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateTagInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateTagInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateTagInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_DeleteAllocationStrategy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.DeleteAllocationStrategyInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalODeleteAllocationStrategyInput2githubcomnetautoresourceManagergraphgraphqlmodelDeleteAllocationStrategyInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_DeleteResourcePool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.DeleteResourcePoolInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDeleteResourcePoolInput2githubcomnetautoresourceManagergraphgraphqlmodelDeleteResourcePoolInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_DeleteResourceType_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.DeleteResourceTypeInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDeleteResourceTypeInput2githubcomnetautoresourceManagergraphgraphqlmodelDeleteResourceTypeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_DeleteTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.DeleteTagInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNDeleteTagInput2githubcomnetautoresourceManagergraphgraphqlmodelDeleteTagInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_FreeResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["poolId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolId"))
		arg1, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["poolId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_TagPool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.TagPoolInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNTagPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelTagPoolInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_TestAllocationStrategy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["allocationStrategyId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allocationStrategyId"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["allocationStrategyId"] = arg0
	var arg1 model.ResourcePoolInput
	if tmp, ok := rawArgs["resourcePool"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourcePool"))
		arg1, err = ec.unmarshalNResourcePoolInput2githubcomnetautoresourceManagergraphgraphqlmodelResourcePoolInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourcePool"] = arg1
	var arg2 []*model.ResourceInput
	if tmp, ok := rawArgs["currentResources"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currentResources"))
		arg2, err = ec.unmarshalNResourceInput2githubcomnetautoresourceManagergraphgraphqlmodelResourceInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currentResources"] = arg2
	var arg3 map[string]interface{}
	if tmp, ok := rawArgs["userInput"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userInput"))
		arg3, err = ec.unmarshalNMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userInput"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_UntagPool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UntagPoolInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUntagPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelUntagPoolInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_UpdateResourceAltId_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["poolId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolId"))
		arg1, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["poolId"] = arg1
	var arg2 map[string]interface{}
	if tmp, ok := rawArgs["alternativeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alternativeId"))
		arg2, err = ec.unmarshalNMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["alternativeId"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_UpdateResourceTypeName_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateResourceTypeNameInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateResourceTypeNameInput2githubcomnetautoresourceManagergraphgraphqlmodelUpdateResourceTypeNameInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_UpdateTag_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateTagInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateTagInput2githubcomnetautoresourceManagergraphgraphqlmodelUpdateTagInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_QueryAllocationStrategies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["byName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byName"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["byName"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_QueryAllocationStrategy_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["allocationStrategyId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allocationStrategyId"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["allocationStrategyId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_QueryEmptyResourcePools_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["resourceTypeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceTypeId"))
		arg0, err = ec.unmarshalOID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceTypeId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg2
	var arg3 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg3, err = ec.unmarshalOCursor2githubcomnetautoresourceManagerentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg3
	var arg4 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg4, err = ec.unmarshalOCursor2githubcomnetautoresourceManagerentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_QueryLeafResourcePools_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["resourceTypeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceTypeId"))
		arg0, err = ec.unmarshalOID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceTypeId"] = arg0
	var arg1 *model.TagOr
	if tmp, ok := rawArgs["tags"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
		arg1, err = ec.unmarshalOTagOr2githubcomnetautoresourceManagergraphgraphqlmodelTagOr(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tags"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg4, err = ec.unmarshalOCursor2githubcomnetautoresourceManagerentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg5, err = ec.unmarshalOCursor2githubcomnetautoresourceManagerentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg5
	var arg6 map[string]interface{}
	if tmp, ok := rawArgs["filterByResources"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filterByResources"))
		arg6, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filterByResources"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_QueryPoolCapacity_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["poolId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolId"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["poolId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_QueryRecentlyActiveResources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["fromDatetime"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fromDatetime"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["fromDatetime"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["toDatetime"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("toDatetime"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["toDatetime"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_QueryRequiredPoolProperties_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["allocationStrategyName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allocationStrategyName"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["allocationStrategyName"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_QueryResourcePoolHierarchyPath_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["poolId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolId"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["poolId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_QueryResourcePool_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["poolId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolId"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["poolId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_QueryResourcePools_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["resourceTypeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceTypeId"))
		arg0, err = ec.unmarshalOID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceTypeId"] = arg0
	var arg1 *model.TagOr
	if tmp, ok := rawArgs["tags"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
		arg1, err = ec.unmarshalOTagOr2githubcomnetautoresourceManagergraphgraphqlmodelTagOr(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tags"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg4, err = ec.unmarshalOCursor2githubcomnetautoresourceManagerentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg5, err = ec.unmarshalOCursor2githubcomnetautoresourceManagerentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg5
	var arg6 map[string]interface{}
	if tmp, ok := rawArgs["filterByResources"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filterByResources"))
		arg6, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filterByResources"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_QueryResourceTypes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["byName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("byName"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["byName"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_QueryResource_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["poolId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolId"))
		arg1, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["poolId"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_QueryResourcesByAltId_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 map[string]interface{}
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["poolId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolId"))
		arg1, err = ec.unmarshalOID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["poolId"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg5, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_QueryResources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["poolId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolId"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["poolId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg4, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_QueryRootResourcePools_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["resourceTypeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceTypeId"))
		arg0, err = ec.unmarshalOID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["resourceTypeId"] = arg0
	var arg1 *model.TagOr
	if tmp, ok := rawArgs["tags"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
		arg1, err = ec.unmarshalOTagOr2githubcomnetautoresourceManagergraphgraphqlmodelTagOr(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tags"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg4, err = ec.unmarshalOCursor2githubcomnetautoresourceManagerentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg4
	var arg5 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg5, err = ec.unmarshalOCursor2githubcomnetautoresourceManagerentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg5
	var arg6 map[string]interface{}
	if tmp, ok := rawArgs["filterByResources"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filterByResources"))
		arg6, err = ec.unmarshalOMap2map(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filterByResources"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_SearchPoolsByTags_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.TagOr
	if tmp, ok := rawArgs["tags"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
		arg0, err = ec.unmarshalOTagOr2githubcomnetautoresourceManagergraphgraphqlmodelTagOr(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tags"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg2
	var arg3 *ent.Cursor
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg3, err = ec.unmarshalOCursor2githubcomnetautoresourceManagerentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg3
	var arg4 *ent.Cursor
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg4, err = ec.unmarshalOCursor2githubcomnetautoresourceManagerentCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_ResourcePool_allocatedResources_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg3, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg3
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AllocationStrategy_Description(ctx context.Context, field graphql.CollectedField, obj *ent.AllocationStrategy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AllocationStrategy_Description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AllocationStrategy_Description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AllocationStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AllocationStrategy_Lang(ctx context.Context, field graphql.CollectedField, obj *ent.AllocationStrategy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AllocationStrategy_Lang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(allocationstrategy.Lang)
	fc.Result = res
	return ec.marshalNAllocationStrategyLang2githubcomnetautoresourceManagerentallocationstrategyLang(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AllocationStrategy_Lang(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AllocationStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AllocationStrategyLang does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AllocationStrategy_Name(ctx context.Context, field graphql.CollectedField, obj *ent.AllocationStrategy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AllocationStrategy_Name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AllocationStrategy_Name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AllocationStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AllocationStrategy_Script(ctx context.Context, field graphql.CollectedField, obj *ent.AllocationStrategy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AllocationStrategy_Script(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Script, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AllocationStrategy_Script(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AllocationStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AllocationStrategy_id(ctx context.Context, field graphql.CollectedField, obj *ent.AllocationStrategy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AllocationStrategy_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AllocationStrategy_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AllocationStrategy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateAllocatingPoolPayload_pool(ctx context.Context, field graphql.CollectedField, obj *model.CreateAllocatingPoolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateAllocatingPoolPayload_pool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pool, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePool)
	fc.Result = res
	return ec.marshalOResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateAllocatingPoolPayload_pool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateAllocatingPoolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "AllocationStrategy":
				return ec.fieldContext_ResourcePool_AllocationStrategy(ctx, field)
			case "Capacity":
				return ec.fieldContext_ResourcePool_Capacity(ctx, field)
			case "Name":
				return ec.fieldContext_ResourcePool_Name(ctx, field)
			case "ParentResource":
				return ec.fieldContext_ResourcePool_ParentResource(ctx, field)
			case "PoolProperties":
				return ec.fieldContext_ResourcePool_PoolProperties(ctx, field)
			case "PoolType":
				return ec.fieldContext_ResourcePool_PoolType(ctx, field)
			case "ResourceType":
				return ec.fieldContext_ResourcePool_ResourceType(ctx, field)
			case "Resources":
				return ec.fieldContext_ResourcePool_Resources(ctx, field)
			case "Tags":
				return ec.fieldContext_ResourcePool_Tags(ctx, field)
			case "allocatedResources":
				return ec.fieldContext_ResourcePool_allocatedResources(ctx, field)
			case "id":
				return ec.fieldContext_ResourcePool_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateAllocationStrategyPayload_strategy(ctx context.Context, field graphql.CollectedField, obj *model.CreateAllocationStrategyPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateAllocationStrategyPayload_strategy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Strategy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AllocationStrategy)
	fc.Result = res
	return ec.marshalOAllocationStrategy2githubcomnetautoresourceManagerentAllocationStrategy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateAllocationStrategyPayload_strategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateAllocationStrategyPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Description":
				return ec.fieldContext_AllocationStrategy_Description(ctx, field)
			case "Lang":
				return ec.fieldContext_AllocationStrategy_Lang(ctx, field)
			case "Name":
				return ec.fieldContext_AllocationStrategy_Name(ctx, field)
			case "Script":
				return ec.fieldContext_AllocationStrategy_Script(ctx, field)
			case "id":
				return ec.fieldContext_AllocationStrategy_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AllocationStrategy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateNestedAllocatingPoolPayload_pool(ctx context.Context, field graphql.CollectedField, obj *model.CreateNestedAllocatingPoolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateNestedAllocatingPoolPayload_pool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pool, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePool)
	fc.Result = res
	return ec.marshalOResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateNestedAllocatingPoolPayload_pool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateNestedAllocatingPoolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "AllocationStrategy":
				return ec.fieldContext_ResourcePool_AllocationStrategy(ctx, field)
			case "Capacity":
				return ec.fieldContext_ResourcePool_Capacity(ctx, field)
			case "Name":
				return ec.fieldContext_ResourcePool_Name(ctx, field)
			case "ParentResource":
				return ec.fieldContext_ResourcePool_ParentResource(ctx, field)
			case "PoolProperties":
				return ec.fieldContext_ResourcePool_PoolProperties(ctx, field)
			case "PoolType":
				return ec.fieldContext_ResourcePool_PoolType(ctx, field)
			case "ResourceType":
				return ec.fieldContext_ResourcePool_ResourceType(ctx, field)
			case "Resources":
				return ec.fieldContext_ResourcePool_Resources(ctx, field)
			case "Tags":
				return ec.fieldContext_ResourcePool_Tags(ctx, field)
			case "allocatedResources":
				return ec.fieldContext_ResourcePool_allocatedResources(ctx, field)
			case "id":
				return ec.fieldContext_ResourcePool_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateNestedSetPoolPayload_pool(ctx context.Context, field graphql.CollectedField, obj *model.CreateNestedSetPoolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateNestedSetPoolPayload_pool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pool, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePool)
	fc.Result = res
	return ec.marshalOResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateNestedSetPoolPayload_pool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateNestedSetPoolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "AllocationStrategy":
				return ec.fieldContext_ResourcePool_AllocationStrategy(ctx, field)
			case "Capacity":
				return ec.fieldContext_ResourcePool_Capacity(ctx, field)
			case "Name":
				return ec.fieldContext_ResourcePool_Name(ctx, field)
			case "ParentResource":
				return ec.fieldContext_ResourcePool_ParentResource(ctx, field)
			case "PoolProperties":
				return ec.fieldContext_ResourcePool_PoolProperties(ctx, field)
			case "PoolType":
				return ec.fieldContext_ResourcePool_PoolType(ctx, field)
			case "ResourceType":
				return ec.fieldContext_ResourcePool_ResourceType(ctx, field)
			case "Resources":
				return ec.fieldContext_ResourcePool_Resources(ctx, field)
			case "Tags":
				return ec.fieldContext_ResourcePool_Tags(ctx, field)
			case "allocatedResources":
				return ec.fieldContext_ResourcePool_allocatedResources(ctx, field)
			case "id":
				return ec.fieldContext_ResourcePool_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateNestedSingletonPoolPayload_pool(ctx context.Context, field graphql.CollectedField, obj *model.CreateNestedSingletonPoolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateNestedSingletonPoolPayload_pool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pool, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePool)
	fc.Result = res
	return ec.marshalOResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateNestedSingletonPoolPayload_pool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateNestedSingletonPoolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "AllocationStrategy":
				return ec.fieldContext_ResourcePool_AllocationStrategy(ctx, field)
			case "Capacity":
				return ec.fieldContext_ResourcePool_Capacity(ctx, field)
			case "Name":
				return ec.fieldContext_ResourcePool_Name(ctx, field)
			case "ParentResource":
				return ec.fieldContext_ResourcePool_ParentResource(ctx, field)
			case "PoolProperties":
				return ec.fieldContext_ResourcePool_PoolProperties(ctx, field)
			case "PoolType":
				return ec.fieldContext_ResourcePool_PoolType(ctx, field)
			case "ResourceType":
				return ec.fieldContext_ResourcePool_ResourceType(ctx, field)
			case "Resources":
				return ec.fieldContext_ResourcePool_Resources(ctx, field)
			case "Tags":
				return ec.fieldContext_ResourcePool_Tags(ctx, field)
			case "allocatedResources":
				return ec.fieldContext_ResourcePool_allocatedResources(ctx, field)
			case "id":
				return ec.fieldContext_ResourcePool_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateResourceTypePayload_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.CreateResourceTypePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateResourceTypePayload_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ResourceType)
	fc.Result = res
	return ec.marshalNResourceType2githubcomnetautoresourceManagerentResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateResourceTypePayload_resourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateResourceTypePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Name":
				return ec.fieldContext_ResourceType_Name(ctx, field)
			case "Pools":
				return ec.fieldContext_ResourceType_Pools(ctx, field)
			case "PropertyTypes":
				return ec.fieldContext_ResourceType_PropertyTypes(ctx, field)
			case "id":
				return ec.fieldContext_ResourceType_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateSetPoolPayload_pool(ctx context.Context, field graphql.CollectedField, obj *model.CreateSetPoolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateSetPoolPayload_pool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pool, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePool)
	fc.Result = res
	return ec.marshalOResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateSetPoolPayload_pool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateSetPoolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "AllocationStrategy":
				return ec.fieldContext_ResourcePool_AllocationStrategy(ctx, field)
			case "Capacity":
				return ec.fieldContext_ResourcePool_Capacity(ctx, field)
			case "Name":
				return ec.fieldContext_ResourcePool_Name(ctx, field)
			case "ParentResource":
				return ec.fieldContext_ResourcePool_ParentResource(ctx, field)
			case "PoolProperties":
				return ec.fieldContext_ResourcePool_PoolProperties(ctx, field)
			case "PoolType":
				return ec.fieldContext_ResourcePool_PoolType(ctx, field)
			case "ResourceType":
				return ec.fieldContext_ResourcePool_ResourceType(ctx, field)
			case "Resources":
				return ec.fieldContext_ResourcePool_Resources(ctx, field)
			case "Tags":
				return ec.fieldContext_ResourcePool_Tags(ctx, field)
			case "allocatedResources":
				return ec.fieldContext_ResourcePool_allocatedResources(ctx, field)
			case "id":
				return ec.fieldContext_ResourcePool_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateSingletonPoolPayload_pool(ctx context.Context, field graphql.CollectedField, obj *model.CreateSingletonPoolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateSingletonPoolPayload_pool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pool, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePool)
	fc.Result = res
	return ec.marshalOResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateSingletonPoolPayload_pool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateSingletonPoolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "AllocationStrategy":
				return ec.fieldContext_ResourcePool_AllocationStrategy(ctx, field)
			case "Capacity":
				return ec.fieldContext_ResourcePool_Capacity(ctx, field)
			case "Name":
				return ec.fieldContext_ResourcePool_Name(ctx, field)
			case "ParentResource":
				return ec.fieldContext_ResourcePool_ParentResource(ctx, field)
			case "PoolProperties":
				return ec.fieldContext_ResourcePool_PoolProperties(ctx, field)
			case "PoolType":
				return ec.fieldContext_ResourcePool_PoolType(ctx, field)
			case "ResourceType":
				return ec.fieldContext_ResourcePool_ResourceType(ctx, field)
			case "Resources":
				return ec.fieldContext_ResourcePool_Resources(ctx, field)
			case "Tags":
				return ec.fieldContext_ResourcePool_Tags(ctx, field)
			case "allocatedResources":
				return ec.fieldContext_ResourcePool_allocatedResources(ctx, field)
			case "id":
				return ec.fieldContext_ResourcePool_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreateTagPayload_tag(ctx context.Context, field graphql.CollectedField, obj *model.CreateTagPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreateTagPayload_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Tag)
	fc.Result = res
	return ec.marshalOTag2githubcomnetautoresourceManagerentTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreateTagPayload_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreateTagPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Pools":
				return ec.fieldContext_Tag_Pools(ctx, field)
			case "Tag":
				return ec.fieldContext_Tag_Tag(ctx, field)
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteAllocationStrategyPayload_strategy(ctx context.Context, field graphql.CollectedField, obj *model.DeleteAllocationStrategyPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteAllocationStrategyPayload_strategy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Strategy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AllocationStrategy)
	fc.Result = res
	return ec.marshalOAllocationStrategy2githubcomnetautoresourceManagerentAllocationStrategy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteAllocationStrategyPayload_strategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteAllocationStrategyPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Description":
				return ec.fieldContext_AllocationStrategy_Description(ctx, field)
			case "Lang":
				return ec.fieldContext_AllocationStrategy_Lang(ctx, field)
			case "Name":
				return ec.fieldContext_AllocationStrategy_Name(ctx, field)
			case "Script":
				return ec.fieldContext_AllocationStrategy_Script(ctx, field)
			case "id":
				return ec.fieldContext_AllocationStrategy_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AllocationStrategy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteResourcePoolPayload_resourcePoolId(ctx context.Context, field graphql.CollectedField, obj *model.DeleteResourcePoolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteResourcePoolPayload_resourcePoolId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourcePoolID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteResourcePoolPayload_resourcePoolId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteResourcePoolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteResourceTypePayload_resourceTypeId(ctx context.Context, field graphql.CollectedField, obj *model.DeleteResourceTypePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteResourceTypePayload_resourceTypeId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceTypeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteResourceTypePayload_resourceTypeId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteResourceTypePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteTagPayload_tagId(ctx context.Context, field graphql.CollectedField, obj *model.DeleteTagPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteTagPayload_tagId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TagID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteTagPayload_tagId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteTagPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTag(rctx, fc.Args["input"].(model.CreateTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CreateTagPayload)
	fc.Result = res
	return ec.marshalNCreateTagPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateTagPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tag":
				return ec.fieldContext_CreateTagPayload_tag(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateTagPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTag(rctx, fc.Args["input"].(model.UpdateTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UpdateTagPayload)
	fc.Result = res
	return ec.marshalNUpdateTagPayload2githubcomnetautoresourceManagergraphgraphqlmodelUpdateTagPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tag":
				return ec.fieldContext_UpdateTagPayload_tag(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateTagPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteTag(rctx, fc.Args["input"].(model.DeleteTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeleteTagPayload)
	fc.Result = res
	return ec.marshalNDeleteTagPayload2githubcomnetautoresourceManagergraphgraphqlmodelDeleteTagPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tagId":
				return ec.fieldContext_DeleteTagPayload_tagId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteTagPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_TagPool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_TagPool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TagPool(rctx, fc.Args["input"].(model.TagPoolInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TagPoolPayload)
	fc.Result = res
	return ec.marshalNTagPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelTagPoolPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_TagPool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tag":
				return ec.fieldContext_TagPoolPayload_tag(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TagPoolPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_TagPool_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UntagPool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UntagPool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UntagPool(rctx, fc.Args["input"].(model.UntagPoolInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UntagPoolPayload)
	fc.Result = res
	return ec.marshalNUntagPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelUntagPoolPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UntagPool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tag":
				return ec.fieldContext_UntagPoolPayload_tag(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UntagPoolPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UntagPool_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateAllocationStrategy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateAllocationStrategy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateAllocationStrategy(rctx, fc.Args["input"].(*model.CreateAllocationStrategyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CreateAllocationStrategyPayload)
	fc.Result = res
	return ec.marshalNCreateAllocationStrategyPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateAllocationStrategyPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateAllocationStrategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "strategy":
				return ec.fieldContext_CreateAllocationStrategyPayload_strategy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateAllocationStrategyPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateAllocationStrategy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteAllocationStrategy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteAllocationStrategy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteAllocationStrategy(rctx, fc.Args["input"].(*model.DeleteAllocationStrategyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeleteAllocationStrategyPayload)
	fc.Result = res
	return ec.marshalNDeleteAllocationStrategyPayload2githubcomnetautoresourceManagergraphgraphqlmodelDeleteAllocationStrategyPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteAllocationStrategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "strategy":
				return ec.fieldContext_DeleteAllocationStrategyPayload_strategy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteAllocationStrategyPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteAllocationStrategy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_TestAllocationStrategy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_TestAllocationStrategy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().TestAllocationStrategy(rctx, fc.Args["allocationStrategyId"].(int), fc.Args["resourcePool"].(model.ResourcePoolInput), fc.Args["currentResources"].([]*model.ResourceInput), fc.Args["userInput"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_TestAllocationStrategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_TestAllocationStrategy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ClaimResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ClaimResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ClaimResource(rctx, fc.Args["poolId"].(int), fc.Args["description"].(*string), fc.Args["userInput"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Resource)
	fc.Result = res
	return ec.marshalNResource2githubcomnetautoresourceManagerentResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ClaimResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Description":
				return ec.fieldContext_Resource_Description(ctx, field)
			case "NestedPool":
				return ec.fieldContext_Resource_NestedPool(ctx, field)
			case "ParentPool":
				return ec.fieldContext_Resource_ParentPool(ctx, field)
			case "Properties":
				return ec.fieldContext_Resource_Properties(ctx, field)
			case "AlternativeId":
				return ec.fieldContext_Resource_AlternativeId(ctx, field)
			case "id":
				return ec.fieldContext_Resource_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Resource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_ClaimResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_ClaimResourceWithAltId(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_ClaimResourceWithAltId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ClaimResourceWithAltID(rctx, fc.Args["poolId"].(int), fc.Args["description"].(*string), fc.Args["userInput"].(map[string]interface{}), fc.Args["alternativeId"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Resource)
	fc.Result = res
	return ec.marshalNResource2githubcomnetautoresourceManagerentResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_ClaimResourceWithAltId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Description":
				return ec.fieldContext_Resource_Description(ctx, field)
			case "NestedPool":
				return ec.fieldContext_Resource_NestedPool(ctx, field)
			case "ParentPool":
				return ec.fieldContext_Resource_ParentPool(ctx, field)
			case "Properties":
				return ec.fieldContext_Resource_Properties(ctx, field)
			case "AlternativeId":
				return ec.fieldContext_Resource_AlternativeId(ctx, field)
			case "id":
				return ec.fieldContext_Resource_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Resource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_ClaimResourceWithAltId_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_FreeResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_FreeResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FreeResource(rctx, fc.Args["input"].(map[string]interface{}), fc.Args["poolId"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_FreeResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_FreeResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateSetPool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateSetPool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateSetPool(rctx, fc.Args["input"].(model.CreateSetPoolInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CreateSetPoolPayload)
	fc.Result = res
	return ec.marshalNCreateSetPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateSetPoolPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateSetPool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pool":
				return ec.fieldContext_CreateSetPoolPayload_pool(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateSetPoolPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateSetPool_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateNestedSetPool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateNestedSetPool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateNestedSetPool(rctx, fc.Args["input"].(model.CreateNestedSetPoolInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CreateNestedSetPoolPayload)
	fc.Result = res
	return ec.marshalNCreateNestedSetPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedSetPoolPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateNestedSetPool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pool":
				return ec.fieldContext_CreateNestedSetPoolPayload_pool(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateNestedSetPoolPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateNestedSetPool_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateSingletonPool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateSingletonPool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateSingletonPool(rctx, fc.Args["input"].(*model.CreateSingletonPoolInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CreateSingletonPoolPayload)
	fc.Result = res
	return ec.marshalNCreateSingletonPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateSingletonPoolPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateSingletonPool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pool":
				return ec.fieldContext_CreateSingletonPoolPayload_pool(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateSingletonPoolPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateSingletonPool_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateNestedSingletonPool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateNestedSingletonPool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateNestedSingletonPool(rctx, fc.Args["input"].(model.CreateNestedSingletonPoolInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CreateNestedSingletonPoolPayload)
	fc.Result = res
	return ec.marshalNCreateNestedSingletonPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedSingletonPoolPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateNestedSingletonPool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pool":
				return ec.fieldContext_CreateNestedSingletonPoolPayload_pool(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateNestedSingletonPoolPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateNestedSingletonPool_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateAllocatingPool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateAllocatingPool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateAllocatingPool(rctx, fc.Args["input"].(*model.CreateAllocatingPoolInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CreateAllocatingPoolPayload)
	fc.Result = res
	return ec.marshalNCreateAllocatingPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateAllocatingPoolPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateAllocatingPool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pool":
				return ec.fieldContext_CreateAllocatingPoolPayload_pool(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateAllocatingPoolPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateAllocatingPool_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateNestedAllocatingPool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateNestedAllocatingPool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateNestedAllocatingPool(rctx, fc.Args["input"].(model.CreateNestedAllocatingPoolInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CreateNestedAllocatingPoolPayload)
	fc.Result = res
	return ec.marshalNCreateNestedAllocatingPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedAllocatingPoolPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateNestedAllocatingPool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pool":
				return ec.fieldContext_CreateNestedAllocatingPoolPayload_pool(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateNestedAllocatingPoolPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateNestedAllocatingPool_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteResourcePool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteResourcePool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteResourcePool(rctx, fc.Args["input"].(model.DeleteResourcePoolInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeleteResourcePoolPayload)
	fc.Result = res
	return ec.marshalNDeleteResourcePoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelDeleteResourcePoolPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteResourcePool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resourcePoolId":
				return ec.fieldContext_DeleteResourcePoolPayload_resourcePoolId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteResourcePoolPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteResourcePool_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_CreateResourceType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_CreateResourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateResourceType(rctx, fc.Args["input"].(model.CreateResourceTypeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CreateResourceTypePayload)
	fc.Result = res
	return ec.marshalNCreateResourceTypePayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateResourceTypePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_CreateResourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resourceType":
				return ec.fieldContext_CreateResourceTypePayload_resourceType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreateResourceTypePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_CreateResourceType_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_DeleteResourceType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_DeleteResourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteResourceType(rctx, fc.Args["input"].(model.DeleteResourceTypeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.DeleteResourceTypePayload)
	fc.Result = res
	return ec.marshalNDeleteResourceTypePayload2githubcomnetautoresourceManagergraphgraphqlmodelDeleteResourceTypePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_DeleteResourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resourceTypeId":
				return ec.fieldContext_DeleteResourceTypePayload_resourceTypeId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteResourceTypePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_DeleteResourceType_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateResourceTypeName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateResourceTypeName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateResourceTypeName(rctx, fc.Args["input"].(model.UpdateResourceTypeNameInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UpdateResourceTypeNamePayload)
	fc.Result = res
	return ec.marshalNUpdateResourceTypeNamePayload2githubcomnetautoresourceManagergraphgraphqlmodelUpdateResourceTypeNamePayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateResourceTypeName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "resourceTypeId":
				return ec.fieldContext_UpdateResourceTypeNamePayload_resourceTypeId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateResourceTypeNamePayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateResourceTypeName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_UpdateResourceAltId(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_UpdateResourceAltId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateResourceAltID(rctx, fc.Args["input"].(map[string]interface{}), fc.Args["poolId"].(int), fc.Args["alternativeId"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Resource)
	fc.Result = res
	return ec.marshalNResource2githubcomnetautoresourceManagerentResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_UpdateResourceAltId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Description":
				return ec.fieldContext_Resource_Description(ctx, field)
			case "NestedPool":
				return ec.fieldContext_Resource_NestedPool(ctx, field)
			case "ParentPool":
				return ec.fieldContext_Resource_ParentPool(ctx, field)
			case "Properties":
				return ec.fieldContext_Resource_Properties(ctx, field)
			case "AlternativeId":
				return ec.fieldContext_Resource_AlternativeId(ctx, field)
			case "id":
				return ec.fieldContext_Resource_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Resource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_UpdateResourceAltId_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _OutputCursor_ID(ctx context.Context, field graphql.CollectedField, obj *ent.Cursor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OutputCursor_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.OutputCursor().ID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OutputCursor_ID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OutputCursor",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Cursor)
	fc.Result = res
	return ec.marshalOOutputCursor2githubcomnetautoresourceManagerentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_OutputCursor_ID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OutputCursor", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *ent.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Cursor)
	fc.Result = res
	return ec.marshalOOutputCursor2githubcomnetautoresourceManagerentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_OutputCursor_ID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OutputCursor", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PoolCapacityPayload_freeCapacity(ctx context.Context, field graphql.CollectedField, obj *model.PoolCapacityPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PoolCapacityPayload_freeCapacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FreeCapacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PoolCapacityPayload_freeCapacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PoolCapacityPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PoolCapacityPayload_utilizedCapacity(ctx context.Context, field graphql.CollectedField, obj *model.PoolCapacityPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PoolCapacityPayload_utilizedCapacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UtilizedCapacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PoolCapacityPayload_utilizedCapacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PoolCapacityPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PropertyType_FloatVal(ctx context.Context, field graphql.CollectedField, obj *ent.PropertyType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PropertyType_FloatVal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FloatVal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PropertyType_FloatVal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PropertyType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PropertyType_IntVal(ctx context.Context, field graphql.CollectedField, obj *ent.PropertyType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PropertyType_IntVal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntVal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PropertyType_IntVal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PropertyType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PropertyType_Mandatory(ctx context.Context, field graphql.CollectedField, obj *ent.PropertyType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PropertyType_Mandatory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mandatory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PropertyType_Mandatory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PropertyType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PropertyType_StringVal(ctx context.Context, field graphql.CollectedField, obj *ent.PropertyType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PropertyType_StringVal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StringVal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PropertyType_StringVal(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PropertyType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PropertyType_Name(ctx context.Context, field graphql.CollectedField, obj *ent.PropertyType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PropertyType_Name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PropertyType_Name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PropertyType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PropertyType_Type(ctx context.Context, field graphql.CollectedField, obj *ent.PropertyType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PropertyType_Type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PropertyType().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PropertyType_Type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PropertyType",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PropertyType_id(ctx context.Context, field graphql.CollectedField, obj *ent.PropertyType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PropertyType_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PropertyType_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PropertyType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryPoolCapacity(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryPoolCapacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryPoolCapacity(rctx, fc.Args["poolId"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PoolCapacityPayload)
	fc.Result = res
	return ec.marshalNPoolCapacityPayload2githubcomnetautoresourceManagergraphgraphqlmodelPoolCapacityPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryPoolCapacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "freeCapacity":
				return ec.fieldContext_PoolCapacityPayload_freeCapacity(ctx, field)
			case "utilizedCapacity":
				return ec.fieldContext_PoolCapacityPayload_utilizedCapacity(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PoolCapacityPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryPoolCapacity_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryPoolTypes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryPoolTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryPoolTypes(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]resourcepool.PoolType)
	fc.Result = res
	return ec.marshalNPoolType2githubcomnetautoresourceManagerentresourcepoolPoolType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryPoolTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PoolType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryResource(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryResource(rctx, fc.Args["input"].(map[string]interface{}), fc.Args["poolId"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Resource)
	fc.Result = res
	return ec.marshalNResource2githubcomnetautoresourceManagerentResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Description":
				return ec.fieldContext_Resource_Description(ctx, field)
			case "NestedPool":
				return ec.fieldContext_Resource_NestedPool(ctx, field)
			case "ParentPool":
				return ec.fieldContext_Resource_ParentPool(ctx, field)
			case "Properties":
				return ec.fieldContext_Resource_Properties(ctx, field)
			case "AlternativeId":
				return ec.fieldContext_Resource_AlternativeId(ctx, field)
			case "id":
				return ec.fieldContext_Resource_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Resource", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryResource_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryResources(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryResources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryResources(rctx, fc.Args["poolId"].(int), fc.Args["first"].(*int), fc.Args["last"].(*int), fc.Args["before"].(*string), fc.Args["after"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ResourceConnection)
	fc.Result = res
	return ec.marshalNResourceConnection2githubcomnetautoresourceManagerentResourceConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryResources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ResourceConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ResourceConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ResourceConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryResources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryResourcesByAltId(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryResourcesByAltId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryResourcesByAltID(rctx, fc.Args["input"].(map[string]interface{}), fc.Args["poolId"].(*int), fc.Args["first"].(*int), fc.Args["last"].(*int), fc.Args["before"].(*string), fc.Args["after"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ResourceConnection)
	fc.Result = res
	return ec.marshalNResourceConnection2githubcomnetautoresourceManagerentResourceConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryResourcesByAltId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ResourceConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ResourceConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ResourceConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryResourcesByAltId_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryAllocationStrategy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryAllocationStrategy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryAllocationStrategy(rctx, fc.Args["allocationStrategyId"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.AllocationStrategy)
	fc.Result = res
	return ec.marshalNAllocationStrategy2githubcomnetautoresourceManagerentAllocationStrategy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryAllocationStrategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Description":
				return ec.fieldContext_AllocationStrategy_Description(ctx, field)
			case "Lang":
				return ec.fieldContext_AllocationStrategy_Lang(ctx, field)
			case "Name":
				return ec.fieldContext_AllocationStrategy_Name(ctx, field)
			case "Script":
				return ec.fieldContext_AllocationStrategy_Script(ctx, field)
			case "id":
				return ec.fieldContext_AllocationStrategy_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AllocationStrategy", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryAllocationStrategy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryAllocationStrategies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryAllocationStrategies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryAllocationStrategies(rctx, fc.Args["byName"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.AllocationStrategy)
	fc.Result = res
	return ec.marshalNAllocationStrategy2githubcomnetautoresourceManagerentAllocationStrategy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryAllocationStrategies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Description":
				return ec.fieldContext_AllocationStrategy_Description(ctx, field)
			case "Lang":
				return ec.fieldContext_AllocationStrategy_Lang(ctx, field)
			case "Name":
				return ec.fieldContext_AllocationStrategy_Name(ctx, field)
			case "Script":
				return ec.fieldContext_AllocationStrategy_Script(ctx, field)
			case "id":
				return ec.fieldContext_AllocationStrategy_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AllocationStrategy", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryAllocationStrategies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryResourceTypes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryResourceTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryResourceTypes(rctx, fc.Args["byName"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ResourceType)
	fc.Result = res
	return ec.marshalNResourceType2githubcomnetautoresourceManagerentResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryResourceTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Name":
				return ec.fieldContext_ResourceType_Name(ctx, field)
			case "Pools":
				return ec.fieldContext_ResourceType_Pools(ctx, field)
			case "PropertyTypes":
				return ec.fieldContext_ResourceType_PropertyTypes(ctx, field)
			case "id":
				return ec.fieldContext_ResourceType_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceType", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryResourceTypes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryRequiredPoolProperties(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryRequiredPoolProperties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryRequiredPoolProperties(rctx, fc.Args["allocationStrategyName"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.PropertyType)
	fc.Result = res
	return ec.marshalNPropertyType2githubcomnetautoresourceManagerentPropertyType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryRequiredPoolProperties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "FloatVal":
				return ec.fieldContext_PropertyType_FloatVal(ctx, field)
			case "IntVal":
				return ec.fieldContext_PropertyType_IntVal(ctx, field)
			case "Mandatory":
				return ec.fieldContext_PropertyType_Mandatory(ctx, field)
			case "StringVal":
				return ec.fieldContext_PropertyType_StringVal(ctx, field)
			case "Name":
				return ec.fieldContext_PropertyType_Name(ctx, field)
			case "Type":
				return ec.fieldContext_PropertyType_Type(ctx, field)
			case "id":
				return ec.fieldContext_PropertyType_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PropertyType", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryRequiredPoolProperties_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryResourcePool(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryResourcePool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryResourcePool(rctx, fc.Args["poolId"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePool)
	fc.Result = res
	return ec.marshalNResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryResourcePool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "AllocationStrategy":
				return ec.fieldContext_ResourcePool_AllocationStrategy(ctx, field)
			case "Capacity":
				return ec.fieldContext_ResourcePool_Capacity(ctx, field)
			case "Name":
				return ec.fieldContext_ResourcePool_Name(ctx, field)
			case "ParentResource":
				return ec.fieldContext_ResourcePool_ParentResource(ctx, field)
			case "PoolProperties":
				return ec.fieldContext_ResourcePool_PoolProperties(ctx, field)
			case "PoolType":
				return ec.fieldContext_ResourcePool_PoolType(ctx, field)
			case "ResourceType":
				return ec.fieldContext_ResourcePool_ResourceType(ctx, field)
			case "Resources":
				return ec.fieldContext_ResourcePool_Resources(ctx, field)
			case "Tags":
				return ec.fieldContext_ResourcePool_Tags(ctx, field)
			case "allocatedResources":
				return ec.fieldContext_ResourcePool_allocatedResources(ctx, field)
			case "id":
				return ec.fieldContext_ResourcePool_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePool", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryResourcePool_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryEmptyResourcePools(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryEmptyResourcePools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryEmptyResourcePools(rctx, fc.Args["resourceTypeId"].(*int), fc.Args["first"].(*int), fc.Args["last"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["after"].(*ent.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePoolConnection)
	fc.Result = res
	return ec.marshalNResourcePoolConnection2githubcomnetautoresourceManagerentResourcePoolConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryEmptyResourcePools(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ResourcePoolConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ResourcePoolConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ResourcePoolConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePoolConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryEmptyResourcePools_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryResourcePools(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryResourcePools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryResourcePools(rctx, fc.Args["resourceTypeId"].(*int), fc.Args["tags"].(*model.TagOr), fc.Args["first"].(*int), fc.Args["last"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["after"].(*ent.Cursor), fc.Args["filterByResources"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePoolConnection)
	fc.Result = res
	return ec.marshalNResourcePoolConnection2githubcomnetautoresourceManagerentResourcePoolConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryResourcePools(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ResourcePoolConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ResourcePoolConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ResourcePoolConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePoolConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryResourcePools_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryRecentlyActiveResources(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryRecentlyActiveResources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryRecentlyActiveResources(rctx, fc.Args["fromDatetime"].(string), fc.Args["toDatetime"].(*string), fc.Args["first"].(*int), fc.Args["last"].(*int), fc.Args["before"].(*string), fc.Args["after"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ResourceConnection)
	fc.Result = res
	return ec.marshalNResourceConnection2githubcomnetautoresourceManagerentResourceConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryRecentlyActiveResources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ResourceConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ResourceConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ResourceConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryRecentlyActiveResources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryResourcePoolHierarchyPath(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryResourcePoolHierarchyPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryResourcePoolHierarchyPath(rctx, fc.Args["poolId"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ResourcePool)
	fc.Result = res
	return ec.marshalNResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryResourcePoolHierarchyPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "AllocationStrategy":
				return ec.fieldContext_ResourcePool_AllocationStrategy(ctx, field)
			case "Capacity":
				return ec.fieldContext_ResourcePool_Capacity(ctx, field)
			case "Name":
				return ec.fieldContext_ResourcePool_Name(ctx, field)
			case "ParentResource":
				return ec.fieldContext_ResourcePool_ParentResource(ctx, field)
			case "PoolProperties":
				return ec.fieldContext_ResourcePool_PoolProperties(ctx, field)
			case "PoolType":
				return ec.fieldContext_ResourcePool_PoolType(ctx, field)
			case "ResourceType":
				return ec.fieldContext_ResourcePool_ResourceType(ctx, field)
			case "Resources":
				return ec.fieldContext_ResourcePool_Resources(ctx, field)
			case "Tags":
				return ec.fieldContext_ResourcePool_Tags(ctx, field)
			case "allocatedResources":
				return ec.fieldContext_ResourcePool_allocatedResources(ctx, field)
			case "id":
				return ec.fieldContext_ResourcePool_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePool", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryResourcePoolHierarchyPath_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryRootResourcePools(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryRootResourcePools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryRootResourcePools(rctx, fc.Args["resourceTypeId"].(*int), fc.Args["tags"].(*model.TagOr), fc.Args["first"].(*int), fc.Args["last"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["after"].(*ent.Cursor), fc.Args["filterByResources"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePoolConnection)
	fc.Result = res
	return ec.marshalNResourcePoolConnection2githubcomnetautoresourceManagerentResourcePoolConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryRootResourcePools(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ResourcePoolConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ResourcePoolConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ResourcePoolConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePoolConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryRootResourcePools_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryLeafResourcePools(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryLeafResourcePools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryLeafResourcePools(rctx, fc.Args["resourceTypeId"].(*int), fc.Args["tags"].(*model.TagOr), fc.Args["first"].(*int), fc.Args["last"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["after"].(*ent.Cursor), fc.Args["filterByResources"].(map[string]interface{}))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePoolConnection)
	fc.Result = res
	return ec.marshalNResourcePoolConnection2githubcomnetautoresourceManagerentResourcePoolConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryLeafResourcePools(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ResourcePoolConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ResourcePoolConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ResourcePoolConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePoolConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_QueryLeafResourcePools_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_SearchPoolsByTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_SearchPoolsByTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SearchPoolsByTags(rctx, fc.Args["tags"].(*model.TagOr), fc.Args["first"].(*int), fc.Args["last"].(*int), fc.Args["before"].(*ent.Cursor), fc.Args["after"].(*ent.Cursor))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePoolConnection)
	fc.Result = res
	return ec.marshalNResourcePoolConnection2githubcomnetautoresourceManagerentResourcePoolConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_SearchPoolsByTags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ResourcePoolConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ResourcePoolConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ResourcePoolConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePoolConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_SearchPoolsByTags_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_QueryTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_QueryTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().QueryTags(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Tag)
	fc.Result = res
	return ec.marshalNTag2githubcomnetautoresourceManagerentTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_QueryTags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Pools":
				return ec.fieldContext_Tag_Pools(ctx, field)
			case "Tag":
				return ec.fieldContext_Tag_Tag(ctx, field)
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(ent.Noder)
	fc.Result = res
	return ec.marshalONode2githubcomnetautoresourceManagerentNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resource_Description(ctx context.Context, field graphql.CollectedField, obj *ent.Resource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resource_Description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resource_Description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resource_NestedPool(ctx context.Context, field graphql.CollectedField, obj *ent.Resource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resource_NestedPool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NestedPool(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePool)
	fc.Result = res
	return ec.marshalOResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resource_NestedPool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resource",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "AllocationStrategy":
				return ec.fieldContext_ResourcePool_AllocationStrategy(ctx, field)
			case "Capacity":
				return ec.fieldContext_ResourcePool_Capacity(ctx, field)
			case "Name":
				return ec.fieldContext_ResourcePool_Name(ctx, field)
			case "ParentResource":
				return ec.fieldContext_ResourcePool_ParentResource(ctx, field)
			case "PoolProperties":
				return ec.fieldContext_ResourcePool_PoolProperties(ctx, field)
			case "PoolType":
				return ec.fieldContext_ResourcePool_PoolType(ctx, field)
			case "ResourceType":
				return ec.fieldContext_ResourcePool_ResourceType(ctx, field)
			case "Resources":
				return ec.fieldContext_ResourcePool_Resources(ctx, field)
			case "Tags":
				return ec.fieldContext_ResourcePool_Tags(ctx, field)
			case "allocatedResources":
				return ec.fieldContext_ResourcePool_allocatedResources(ctx, field)
			case "id":
				return ec.fieldContext_ResourcePool_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resource_ParentPool(ctx context.Context, field graphql.CollectedField, obj *ent.Resource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resource_ParentPool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Resource().ParentPool(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePool)
	fc.Result = res
	return ec.marshalNResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resource_ParentPool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resource",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "AllocationStrategy":
				return ec.fieldContext_ResourcePool_AllocationStrategy(ctx, field)
			case "Capacity":
				return ec.fieldContext_ResourcePool_Capacity(ctx, field)
			case "Name":
				return ec.fieldContext_ResourcePool_Name(ctx, field)
			case "ParentResource":
				return ec.fieldContext_ResourcePool_ParentResource(ctx, field)
			case "PoolProperties":
				return ec.fieldContext_ResourcePool_PoolProperties(ctx, field)
			case "PoolType":
				return ec.fieldContext_ResourcePool_PoolType(ctx, field)
			case "ResourceType":
				return ec.fieldContext_ResourcePool_ResourceType(ctx, field)
			case "Resources":
				return ec.fieldContext_ResourcePool_Resources(ctx, field)
			case "Tags":
				return ec.fieldContext_ResourcePool_Tags(ctx, field)
			case "allocatedResources":
				return ec.fieldContext_ResourcePool_allocatedResources(ctx, field)
			case "id":
				return ec.fieldContext_ResourcePool_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resource_Properties(ctx context.Context, field graphql.CollectedField, obj *ent.Resource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resource_Properties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Resource().Properties(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resource_Properties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resource",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resource_AlternativeId(ctx context.Context, field graphql.CollectedField, obj *ent.Resource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resource_AlternativeId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Resource().AlternativeID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resource_AlternativeId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resource",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Resource_id(ctx context.Context, field graphql.CollectedField, obj *ent.Resource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Resource_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Resource_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Resource",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.ResourceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ResourceEdge)
	fc.Result = res
	return ec.marshalNResourceEdge2githubcomnetautoresourceManagerentResourceEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ResourceEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ResourceEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.ResourceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnetautoresourceManagerentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.ResourceConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.ResourceEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNOutputCursor2githubcomnetautoresourceManagerentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_OutputCursor_ID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OutputCursor", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.ResourceEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.Resource)
	fc.Result = res
	return ec.marshalNResource2githubcomnetautoresourceManagerentResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Description":
				return ec.fieldContext_Resource_Description(ctx, field)
			case "NestedPool":
				return ec.fieldContext_Resource_NestedPool(ctx, field)
			case "ParentPool":
				return ec.fieldContext_Resource_ParentPool(ctx, field)
			case "Properties":
				return ec.fieldContext_Resource_Properties(ctx, field)
			case "AlternativeId":
				return ec.fieldContext_Resource_AlternativeId(ctx, field)
			case "id":
				return ec.fieldContext_Resource_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Resource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePool_AllocationStrategy(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePool_AllocationStrategy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllocationStrategy(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.AllocationStrategy)
	fc.Result = res
	return ec.marshalOAllocationStrategy2githubcomnetautoresourceManagerentAllocationStrategy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePool_AllocationStrategy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePool",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Description":
				return ec.fieldContext_AllocationStrategy_Description(ctx, field)
			case "Lang":
				return ec.fieldContext_AllocationStrategy_Lang(ctx, field)
			case "Name":
				return ec.fieldContext_AllocationStrategy_Name(ctx, field)
			case "Script":
				return ec.fieldContext_AllocationStrategy_Script(ctx, field)
			case "id":
				return ec.fieldContext_AllocationStrategy_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AllocationStrategy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePool_Capacity(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePool_Capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ResourcePool().Capacity(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PoolCapacityPayload)
	fc.Result = res
	return ec.marshalOPoolCapacityPayload2githubcomnetautoresourceManagergraphgraphqlmodelPoolCapacityPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePool_Capacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePool",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "freeCapacity":
				return ec.fieldContext_PoolCapacityPayload_freeCapacity(ctx, field)
			case "utilizedCapacity":
				return ec.fieldContext_PoolCapacityPayload_utilizedCapacity(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PoolCapacityPayload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePool_Name(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePool_Name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePool_Name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePool_ParentResource(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePool_ParentResource(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentResource(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Resource)
	fc.Result = res
	return ec.marshalOResource2githubcomnetautoresourceManagerentResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePool_ParentResource(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePool",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Description":
				return ec.fieldContext_Resource_Description(ctx, field)
			case "NestedPool":
				return ec.fieldContext_Resource_NestedPool(ctx, field)
			case "ParentPool":
				return ec.fieldContext_Resource_ParentPool(ctx, field)
			case "Properties":
				return ec.fieldContext_Resource_Properties(ctx, field)
			case "AlternativeId":
				return ec.fieldContext_Resource_AlternativeId(ctx, field)
			case "id":
				return ec.fieldContext_Resource_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Resource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePool_PoolProperties(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePool_PoolProperties(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ResourcePool().PoolProperties(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePool_PoolProperties(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePool",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePool_PoolType(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePool_PoolType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PoolType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(resourcepool.PoolType)
	fc.Result = res
	return ec.marshalNPoolType2githubcomnetautoresourceManagerentresourcepoolPoolType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePool_PoolType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PoolType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePool_ResourceType(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePool_ResourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ResourceType)
	fc.Result = res
	return ec.marshalNResourceType2githubcomnetautoresourceManagerentResourceType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePool_ResourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePool",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Name":
				return ec.fieldContext_ResourceType_Name(ctx, field)
			case "Pools":
				return ec.fieldContext_ResourceType_Pools(ctx, field)
			case "PropertyTypes":
				return ec.fieldContext_ResourceType_PropertyTypes(ctx, field)
			case "id":
				return ec.fieldContext_ResourceType_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePool_Resources(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePool_Resources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ResourcePool().Resources(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Resource)
	fc.Result = res
	return ec.marshalNResource2githubcomnetautoresourceManagerentResource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePool_Resources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePool",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Description":
				return ec.fieldContext_Resource_Description(ctx, field)
			case "NestedPool":
				return ec.fieldContext_Resource_NestedPool(ctx, field)
			case "ParentPool":
				return ec.fieldContext_Resource_ParentPool(ctx, field)
			case "Properties":
				return ec.fieldContext_Resource_Properties(ctx, field)
			case "AlternativeId":
				return ec.fieldContext_Resource_AlternativeId(ctx, field)
			case "id":
				return ec.fieldContext_Resource_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Resource", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePool_Tags(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePool_Tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.Tag)
	fc.Result = res
	return ec.marshalNTag2githubcomnetautoresourceManagerentTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePool_Tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePool",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Pools":
				return ec.fieldContext_Tag_Pools(ctx, field)
			case "Tag":
				return ec.fieldContext_Tag_Tag(ctx, field)
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePool_allocatedResources(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePool_allocatedResources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ResourcePool().AllocatedResources(rctx, obj, fc.Args["first"].(*int), fc.Args["last"].(*int), fc.Args["before"].(*string), fc.Args["after"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.ResourceConnection)
	fc.Result = res
	return ec.marshalOResourceConnection2githubcomnetautoresourceManagerentResourceConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePool_allocatedResources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePool",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ResourceConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ResourceConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ResourceConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ResourcePool_allocatedResources_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePool_id(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePool_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePool_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePoolConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePoolConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePoolConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ResourcePoolEdge)
	fc.Result = res
	return ec.marshalNResourcePoolEdge2githubcomnetautoresourceManagerentResourcePoolEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePoolConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePoolConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cursor":
				return ec.fieldContext_ResourcePoolEdge_cursor(ctx, field)
			case "node":
				return ec.fieldContext_ResourcePoolEdge_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePoolEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePoolConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePoolConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePoolConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.PageInfo)
	fc.Result = res
	return ec.marshalNPageInfo2githubcomnetautoresourceManagerentPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePoolConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePoolConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePoolConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePoolConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePoolConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePoolConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePoolConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePoolEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePoolEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePoolEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ent.Cursor)
	fc.Result = res
	return ec.marshalNOutputCursor2githubcomnetautoresourceManagerentCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePoolEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePoolEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_OutputCursor_ID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OutputCursor", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourcePoolEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.ResourcePoolEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourcePoolEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ResourcePool)
	fc.Result = res
	return ec.marshalNResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourcePoolEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourcePoolEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "AllocationStrategy":
				return ec.fieldContext_ResourcePool_AllocationStrategy(ctx, field)
			case "Capacity":
				return ec.fieldContext_ResourcePool_Capacity(ctx, field)
			case "Name":
				return ec.fieldContext_ResourcePool_Name(ctx, field)
			case "ParentResource":
				return ec.fieldContext_ResourcePool_ParentResource(ctx, field)
			case "PoolProperties":
				return ec.fieldContext_ResourcePool_PoolProperties(ctx, field)
			case "PoolType":
				return ec.fieldContext_ResourcePool_PoolType(ctx, field)
			case "ResourceType":
				return ec.fieldContext_ResourcePool_ResourceType(ctx, field)
			case "Resources":
				return ec.fieldContext_ResourcePool_Resources(ctx, field)
			case "Tags":
				return ec.fieldContext_ResourcePool_Tags(ctx, field)
			case "allocatedResources":
				return ec.fieldContext_ResourcePool_allocatedResources(ctx, field)
			case "id":
				return ec.fieldContext_ResourcePool_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceType_Name(ctx context.Context, field graphql.CollectedField, obj *ent.ResourceType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceType_Name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceType_Name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceType_Pools(ctx context.Context, field graphql.CollectedField, obj *ent.ResourceType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceType_Pools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pools(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.ResourcePool)
	fc.Result = res
	return ec.marshalNResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceType_Pools(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceType",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "AllocationStrategy":
				return ec.fieldContext_ResourcePool_AllocationStrategy(ctx, field)
			case "Capacity":
				return ec.fieldContext_ResourcePool_Capacity(ctx, field)
			case "Name":
				return ec.fieldContext_ResourcePool_Name(ctx, field)
			case "ParentResource":
				return ec.fieldContext_ResourcePool_ParentResource(ctx, field)
			case "PoolProperties":
				return ec.fieldContext_ResourcePool_PoolProperties(ctx, field)
			case "PoolType":
				return ec.fieldContext_ResourcePool_PoolType(ctx, field)
			case "ResourceType":
				return ec.fieldContext_ResourcePool_ResourceType(ctx, field)
			case "Resources":
				return ec.fieldContext_ResourcePool_Resources(ctx, field)
			case "Tags":
				return ec.fieldContext_ResourcePool_Tags(ctx, field)
			case "allocatedResources":
				return ec.fieldContext_ResourcePool_allocatedResources(ctx, field)
			case "id":
				return ec.fieldContext_ResourcePool_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceType_PropertyTypes(ctx context.Context, field graphql.CollectedField, obj *ent.ResourceType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceType_PropertyTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PropertyTypes(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ent.PropertyType)
	fc.Result = res
	return ec.marshalNPropertyType2githubcomnetautoresourceManagerentPropertyType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceType_PropertyTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceType",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "FloatVal":
				return ec.fieldContext_PropertyType_FloatVal(ctx, field)
			case "IntVal":
				return ec.fieldContext_PropertyType_IntVal(ctx, field)
			case "Mandatory":
				return ec.fieldContext_PropertyType_Mandatory(ctx, field)
			case "StringVal":
				return ec.fieldContext_PropertyType_StringVal(ctx, field)
			case "Name":
				return ec.fieldContext_PropertyType_Name(ctx, field)
			case "Type":
				return ec.fieldContext_PropertyType_Type(ctx, field)
			case "id":
				return ec.fieldContext_PropertyType_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PropertyType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceType_id(ctx context.Context, field graphql.CollectedField, obj *ent.ResourceType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceType_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceType_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_Pools(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_Pools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pools(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ResourcePool)
	fc.Result = res
	return ec.marshalOResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_Pools(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "AllocationStrategy":
				return ec.fieldContext_ResourcePool_AllocationStrategy(ctx, field)
			case "Capacity":
				return ec.fieldContext_ResourcePool_Capacity(ctx, field)
			case "Name":
				return ec.fieldContext_ResourcePool_Name(ctx, field)
			case "ParentResource":
				return ec.fieldContext_ResourcePool_ParentResource(ctx, field)
			case "PoolProperties":
				return ec.fieldContext_ResourcePool_PoolProperties(ctx, field)
			case "PoolType":
				return ec.fieldContext_ResourcePool_PoolType(ctx, field)
			case "ResourceType":
				return ec.fieldContext_ResourcePool_ResourceType(ctx, field)
			case "Resources":
				return ec.fieldContext_ResourcePool_Resources(ctx, field)
			case "Tags":
				return ec.fieldContext_ResourcePool_Tags(ctx, field)
			case "allocatedResources":
				return ec.fieldContext_ResourcePool_allocatedResources(ctx, field)
			case "id":
				return ec.fieldContext_ResourcePool_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourcePool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_Tag(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_Tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_Tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Tag_id(ctx context.Context, field graphql.CollectedField, obj *ent.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Tag_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Tag_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Tag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TagPoolPayload_tag(ctx context.Context, field graphql.CollectedField, obj *model.TagPoolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TagPoolPayload_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Tag)
	fc.Result = res
	return ec.marshalOTag2githubcomnetautoresourceManagerentTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TagPoolPayload_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TagPoolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Pools":
				return ec.fieldContext_Tag_Pools(ctx, field)
			case "Tag":
				return ec.fieldContext_Tag_Tag(ctx, field)
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UntagPoolPayload_tag(ctx context.Context, field graphql.CollectedField, obj *model.UntagPoolPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UntagPoolPayload_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Tag)
	fc.Result = res
	return ec.marshalOTag2githubcomnetautoresourceManagerentTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UntagPoolPayload_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UntagPoolPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Pools":
				return ec.fieldContext_Tag_Pools(ctx, field)
			case "Tag":
				return ec.fieldContext_Tag_Tag(ctx, field)
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateResourceTypeNamePayload_resourceTypeId(ctx context.Context, field graphql.CollectedField, obj *model.UpdateResourceTypeNamePayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateResourceTypeNamePayload_resourceTypeId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceTypeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNID2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateResourceTypeNamePayload_resourceTypeId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateResourceTypeNamePayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateTagPayload_tag(ctx context.Context, field graphql.CollectedField, obj *model.UpdateTagPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateTagPayload_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Tag)
	fc.Result = res
	return ec.marshalOTag2githubcomnetautoresourceManagerentTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateTagPayload_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateTagPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Pools":
				return ec.fieldContext_Tag_Pools(ctx, field)
			case "Tag":
				return ec.fieldContext_Tag_Tag(ctx, field)
			case "id":
				return ec.fieldContext_Tag_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Tag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCreateAllocatingPoolInput(ctx context.Context, obj interface{}) (model.CreateAllocatingPoolInput, error) {
	var it model.CreateAllocatingPoolInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"allocationStrategyId", "description", "poolDealocationSafetyPeriod", "poolName", "poolProperties", "poolPropertyTypes", "resourceTypeId", "tags"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "allocationStrategyId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allocationStrategyId"))
			it.AllocationStrategyID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolDealocationSafetyPeriod":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolDealocationSafetyPeriod"))
			it.PoolDealocationSafetyPeriod, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolName"))
			it.PoolName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolProperties":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolProperties"))
			it.PoolProperties, err = ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolPropertyTypes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolPropertyTypes"))
			it.PoolPropertyTypes, err = ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		case "resourceTypeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceTypeId"))
			it.ResourceTypeID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateAllocationStrategyInput(ctx context.Context, obj interface{}) (model.CreateAllocationStrategyInput, error) {
	var it model.CreateAllocationStrategyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "script", "lang", "expectedPoolPropertyTypes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "script":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("script"))
			it.Script, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "lang":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lang"))
			it.Lang, err = ec.unmarshalNAllocationStrategyLang2githubcomnetautoresourceManagerentallocationstrategyLang(ctx, v)
			if err != nil {
				return it, err
			}
		case "expectedPoolPropertyTypes":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expectedPoolPropertyTypes"))
			it.ExpectedPoolPropertyTypes, err = ec.unmarshalOMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateNestedAllocatingPoolInput(ctx context.Context, obj interface{}) (model.CreateNestedAllocatingPoolInput, error) {
	var it model.CreateNestedAllocatingPoolInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"allocationStrategyId", "description", "parentResourceId", "poolDealocationSafetyPeriod", "poolName", "resourceTypeId", "tags"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "allocationStrategyId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allocationStrategyId"))
			it.AllocationStrategyID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentResourceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentResourceId"))
			it.ParentResourceID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolDealocationSafetyPeriod":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolDealocationSafetyPeriod"))
			it.PoolDealocationSafetyPeriod, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolName"))
			it.PoolName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "resourceTypeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceTypeId"))
			it.ResourceTypeID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateNestedSetPoolInput(ctx context.Context, obj interface{}) (model.CreateNestedSetPoolInput, error) {
	var it model.CreateNestedSetPoolInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"description", "parentResourceId", "poolDealocationSafetyPeriod", "poolName", "poolValues", "resourceTypeId", "tags"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentResourceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentResourceId"))
			it.ParentResourceID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolDealocationSafetyPeriod":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolDealocationSafetyPeriod"))
			it.PoolDealocationSafetyPeriod, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolName"))
			it.PoolName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolValues":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolValues"))
			it.PoolValues, err = ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		case "resourceTypeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceTypeId"))
			it.ResourceTypeID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateNestedSingletonPoolInput(ctx context.Context, obj interface{}) (model.CreateNestedSingletonPoolInput, error) {
	var it model.CreateNestedSingletonPoolInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"description", "parentResourceId", "poolName", "poolValues", "resourceTypeId", "tags"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "parentResourceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentResourceId"))
			it.ParentResourceID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolName"))
			it.PoolName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolValues":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolValues"))
			it.PoolValues, err = ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		case "resourceTypeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceTypeId"))
			it.ResourceTypeID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateResourceTypeInput(ctx context.Context, obj interface{}) (model.CreateResourceTypeInput, error) {
	var it model.CreateResourceTypeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"resourceName", "resourceProperties"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "resourceName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceName"))
			it.ResourceName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "resourceProperties":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceProperties"))
			it.ResourceProperties, err = ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateSetPoolInput(ctx context.Context, obj interface{}) (model.CreateSetPoolInput, error) {
	var it model.CreateSetPoolInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"description", "poolDealocationSafetyPeriod", "poolName", "poolValues", "resourceTypeId", "tags"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolDealocationSafetyPeriod":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolDealocationSafetyPeriod"))
			it.PoolDealocationSafetyPeriod, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolName"))
			it.PoolName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolValues":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolValues"))
			it.PoolValues, err = ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		case "resourceTypeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceTypeId"))
			it.ResourceTypeID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateSingletonPoolInput(ctx context.Context, obj interface{}) (model.CreateSingletonPoolInput, error) {
	var it model.CreateSingletonPoolInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"description", "poolName", "poolValues", "resourceTypeId", "tags"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolName"))
			it.PoolName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolValues":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolValues"))
			it.PoolValues, err = ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		case "resourceTypeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceTypeId"))
			it.ResourceTypeID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			it.Tags, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTagInput(ctx context.Context, obj interface{}) (model.CreateTagInput, error) {
	var it model.CreateTagInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tagText"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tagText":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagText"))
			it.TagText, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteAllocationStrategyInput(ctx context.Context, obj interface{}) (model.DeleteAllocationStrategyInput, error) {
	var it model.DeleteAllocationStrategyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"allocationStrategyId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "allocationStrategyId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allocationStrategyId"))
			it.AllocationStrategyID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteResourcePoolInput(ctx context.Context, obj interface{}) (model.DeleteResourcePoolInput, error) {
	var it model.DeleteResourcePoolInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"resourcePoolId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "resourcePoolId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourcePoolId"))
			it.ResourcePoolID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteResourceTypeInput(ctx context.Context, obj interface{}) (model.DeleteResourceTypeInput, error) {
	var it model.DeleteResourceTypeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"resourceTypeId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "resourceTypeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceTypeId"))
			it.ResourceTypeID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteTagInput(ctx context.Context, obj interface{}) (model.DeleteTagInput, error) {
	var it model.DeleteTagInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tagId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tagId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagId"))
			it.TagID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResourceInput(ctx context.Context, obj interface{}) (model.ResourceInput, error) {
	var it model.ResourceInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Properties", "Status", "UpdatedAt"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Properties":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Properties"))
			it.Properties, err = ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		case "Status":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Status"))
			it.Status, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "UpdatedAt":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("UpdatedAt"))
			it.UpdatedAt, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResourcePoolInput(ctx context.Context, obj interface{}) (model.ResourcePoolInput, error) {
	var it model.ResourcePoolInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ResourcePoolID", "ResourcePoolName", "poolProperties"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ResourcePoolID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ResourcePoolID"))
			it.ResourcePoolID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "ResourcePoolName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ResourcePoolName"))
			it.ResourcePoolName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolProperties":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolProperties"))
			it.PoolProperties, err = ec.unmarshalNMap2map(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagAnd(ctx context.Context, obj interface{}) (model.TagAnd, error) {
	var it model.TagAnd
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchesAll"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchesAll":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchesAll"))
			it.MatchesAll, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagOr(ctx context.Context, obj interface{}) (model.TagOr, error) {
	var it model.TagOr
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"matchesAny"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "matchesAny":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("matchesAny"))
			it.MatchesAny, err = ec.unmarshalNTagAnd2githubcomnetautoresourceManagergraphgraphqlmodelTagAnd(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTagPoolInput(ctx context.Context, obj interface{}) (model.TagPoolInput, error) {
	var it model.TagPoolInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tagId", "poolId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tagId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagId"))
			it.TagID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolId"))
			it.PoolID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUntagPoolInput(ctx context.Context, obj interface{}) (model.UntagPoolInput, error) {
	var it model.UntagPoolInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tagId", "poolId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tagId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagId"))
			it.TagID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "poolId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolId"))
			it.PoolID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateResourceTypeNameInput(ctx context.Context, obj interface{}) (model.UpdateResourceTypeNameInput, error) {
	var it model.UpdateResourceTypeNameInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"resourceTypeId", "resourceName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "resourceTypeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceTypeId"))
			it.ResourceTypeID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "resourceName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceName"))
			it.ResourceName, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTagInput(ctx context.Context, obj interface{}) (model.UpdateTagInput, error) {
	var it model.UpdateTagInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tagId", "tagText"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tagId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagId"))
			it.TagID, err = ec.unmarshalNID2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "tagText":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagText"))
			it.TagText, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj ent.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.ResourceType:
		if obj == nil {
			return graphql.Null
		}
		return ec._ResourceType(ctx, sel, obj)
	case *ent.PropertyType:
		if obj == nil {
			return graphql.Null
		}
		return ec._PropertyType(ctx, sel, obj)
	case *ent.ResourcePool:
		if obj == nil {
			return graphql.Null
		}
		return ec._ResourcePool(ctx, sel, obj)
	case *ent.Resource:
		if obj == nil {
			return graphql.Null
		}
		return ec._Resource(ctx, sel, obj)
	case *ent.AllocationStrategy:
		if obj == nil {
			return graphql.Null
		}
		return ec._AllocationStrategy(ctx, sel, obj)
	case *ent.Tag:
		if obj == nil {
			return graphql.Null
		}
		return ec._Tag(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var allocationStrategyImplementors = []string{"AllocationStrategy", "Node"}

func (ec *executionContext) _AllocationStrategy(ctx context.Context, sel ast.SelectionSet, obj *ent.AllocationStrategy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, allocationStrategyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AllocationStrategy")
		case "Description":

			out.Values[i] = ec._AllocationStrategy_Description(ctx, field, obj)

		case "Lang":

			out.Values[i] = ec._AllocationStrategy_Lang(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Name":

			out.Values[i] = ec._AllocationStrategy_Name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "Script":

			out.Values[i] = ec._AllocationStrategy_Script(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "id":

			out.Values[i] = ec._AllocationStrategy_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var createAllocatingPoolPayloadImplementors = []string{"CreateAllocatingPoolPayload"}

func (ec *executionContext) _CreateAllocatingPoolPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateAllocatingPoolPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createAllocatingPoolPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateAllocatingPoolPayload")
		case "pool":

			out.Values[i] = ec._CreateAllocatingPoolPayload_pool(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var createAllocationStrategyPayloadImplementors = []string{"CreateAllocationStrategyPayload"}

func (ec *executionContext) _CreateAllocationStrategyPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateAllocationStrategyPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createAllocationStrategyPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateAllocationStrategyPayload")
		case "strategy":

			out.Values[i] = ec._CreateAllocationStrategyPayload_strategy(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var createNestedAllocatingPoolPayloadImplementors = []string{"CreateNestedAllocatingPoolPayload"}

func (ec *executionContext) _CreateNestedAllocatingPoolPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateNestedAllocatingPoolPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createNestedAllocatingPoolPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateNestedAllocatingPoolPayload")
		case "pool":

			out.Values[i] = ec._CreateNestedAllocatingPoolPayload_pool(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var createNestedSetPoolPayloadImplementors = []string{"CreateNestedSetPoolPayload"}

func (ec *executionContext) _CreateNestedSetPoolPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateNestedSetPoolPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createNestedSetPoolPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateNestedSetPoolPayload")
		case "pool":

			out.Values[i] = ec._CreateNestedSetPoolPayload_pool(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var createNestedSingletonPoolPayloadImplementors = []string{"CreateNestedSingletonPoolPayload"}

func (ec *executionContext) _CreateNestedSingletonPoolPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateNestedSingletonPoolPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createNestedSingletonPoolPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateNestedSingletonPoolPayload")
		case "pool":

			out.Values[i] = ec._CreateNestedSingletonPoolPayload_pool(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var createResourceTypePayloadImplementors = []string{"CreateResourceTypePayload"}

func (ec *executionContext) _CreateResourceTypePayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateResourceTypePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createResourceTypePayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateResourceTypePayload")
		case "resourceType":

			out.Values[i] = ec._CreateResourceTypePayload_resourceType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var createSetPoolPayloadImplementors = []string{"CreateSetPoolPayload"}

func (ec *executionContext) _CreateSetPoolPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateSetPoolPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createSetPoolPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateSetPoolPayload")
		case "pool":

			out.Values[i] = ec._CreateSetPoolPayload_pool(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var createSingletonPoolPayloadImplementors = []string{"CreateSingletonPoolPayload"}

func (ec *executionContext) _CreateSingletonPoolPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateSingletonPoolPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createSingletonPoolPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateSingletonPoolPayload")
		case "pool":

			out.Values[i] = ec._CreateSingletonPoolPayload_pool(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var createTagPayloadImplementors = []string{"CreateTagPayload"}

func (ec *executionContext) _CreateTagPayload(ctx context.Context, sel ast.SelectionSet, obj *model.CreateTagPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, createTagPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreateTagPayload")
		case "tag":

			out.Values[i] = ec._CreateTagPayload_tag(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deleteAllocationStrategyPayloadImplementors = []string{"DeleteAllocationStrategyPayload"}

func (ec *executionContext) _DeleteAllocationStrategyPayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteAllocationStrategyPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteAllocationStrategyPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteAllocationStrategyPayload")
		case "strategy":

			out.Values[i] = ec._DeleteAllocationStrategyPayload_strategy(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deleteResourcePoolPayloadImplementors = []string{"DeleteResourcePoolPayload"}

func (ec *executionContext) _DeleteResourcePoolPayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteResourcePoolPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteResourcePoolPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteResourcePoolPayload")
		case "resourcePoolId":

			out.Values[i] = ec._DeleteResourcePoolPayload_resourcePoolId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deleteResourceTypePayloadImplementors = []string{"DeleteResourceTypePayload"}

func (ec *executionContext) _DeleteResourceTypePayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteResourceTypePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteResourceTypePayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteResourceTypePayload")
		case "resourceTypeId":

			out.Values[i] = ec._DeleteResourceTypePayload_resourceTypeId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deleteTagPayloadImplementors = []string{"DeleteTagPayload"}

func (ec *executionContext) _DeleteTagPayload(ctx context.Context, sel ast.SelectionSet, obj *model.DeleteTagPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteTagPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteTagPayload")
		case "tagId":

			out.Values[i] = ec._DeleteTagPayload_tagId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "CreateTag":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateTag(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "UpdateTag":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateTag(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "DeleteTag":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteTag(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "TagPool":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_TagPool(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "UntagPool":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UntagPool(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CreateAllocationStrategy":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateAllocationStrategy(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "DeleteAllocationStrategy":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteAllocationStrategy(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "TestAllocationStrategy":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_TestAllocationStrategy(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ClaimResource":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ClaimResource(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ClaimResourceWithAltId":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_ClaimResourceWithAltId(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "FreeResource":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_FreeResource(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CreateSetPool":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateSetPool(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CreateNestedSetPool":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateNestedSetPool(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CreateSingletonPool":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateSingletonPool(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CreateNestedSingletonPool":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateNestedSingletonPool(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CreateAllocatingPool":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateAllocatingPool(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CreateNestedAllocatingPool":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateNestedAllocatingPool(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "DeleteResourcePool":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteResourcePool(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "CreateResourceType":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_CreateResourceType(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "DeleteResourceType":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_DeleteResourceType(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "UpdateResourceTypeName":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateResourceTypeName(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "UpdateResourceAltId":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_UpdateResourceAltId(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var outputCursorImplementors = []string{"OutputCursor"}

func (ec *executionContext) _OutputCursor(ctx context.Context, sel ast.SelectionSet, obj *ent.Cursor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, outputCursorImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OutputCursor")
		case "ID":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._OutputCursor_ID(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *ent.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "endCursor":

			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)

		case "hasNextPage":

			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hasPreviousPage":

			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startCursor":

			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var poolCapacityPayloadImplementors = []string{"PoolCapacityPayload"}

func (ec *executionContext) _PoolCapacityPayload(ctx context.Context, sel ast.SelectionSet, obj *model.PoolCapacityPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, poolCapacityPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PoolCapacityPayload")
		case "freeCapacity":

			out.Values[i] = ec._PoolCapacityPayload_freeCapacity(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "utilizedCapacity":

			out.Values[i] = ec._PoolCapacityPayload_utilizedCapacity(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var propertyTypeImplementors = []string{"PropertyType", "Node"}

func (ec *executionContext) _PropertyType(ctx context.Context, sel ast.SelectionSet, obj *ent.PropertyType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, propertyTypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PropertyType")
		case "FloatVal":

			out.Values[i] = ec._PropertyType_FloatVal(ctx, field, obj)

		case "IntVal":

			out.Values[i] = ec._PropertyType_IntVal(ctx, field, obj)

		case "Mandatory":

			out.Values[i] = ec._PropertyType_Mandatory(ctx, field, obj)

		case "StringVal":

			out.Values[i] = ec._PropertyType_StringVal(ctx, field, obj)

		case "Name":

			out.Values[i] = ec._PropertyType_Name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PropertyType_Type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "id":

			out.Values[i] = ec._PropertyType_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "QueryPoolCapacity":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryPoolCapacity(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryPoolTypes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryPoolTypes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryResource":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryResource(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryResources":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryResources(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryResourcesByAltId":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryResourcesByAltId(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryAllocationStrategy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryAllocationStrategy(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryAllocationStrategies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryAllocationStrategies(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryResourceTypes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryResourceTypes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryRequiredPoolProperties":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryRequiredPoolProperties(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryResourcePool":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryResourcePool(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryEmptyResourcePools":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryEmptyResourcePools(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryResourcePools":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryResourcePools(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryRecentlyActiveResources":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryRecentlyActiveResources(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryResourcePoolHierarchyPath":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryResourcePoolHierarchyPath(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryRootResourcePools":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryRootResourcePools(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryLeafResourcePools":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryLeafResourcePools(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "SearchPoolsByTags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_SearchPoolsByTags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "QueryTags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_QueryTags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "node":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var resourceImplementors = []string{"Resource", "Node"}

func (ec *executionContext) _Resource(ctx context.Context, sel ast.SelectionSet, obj *ent.Resource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Resource")
		case "Description":

			out.Values[i] = ec._Resource_Description(ctx, field, obj)

		case "NestedPool":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Resource_NestedPool(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "ParentPool":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Resource_ParentPool(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Properties":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Resource_Properties(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "AlternativeId":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Resource_AlternativeId(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "id":

			out.Values[i] = ec._Resource_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var resourceConnectionImplementors = []string{"ResourceConnection"}

func (ec *executionContext) _ResourceConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.ResourceConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceConnection")
		case "edges":

			out.Values[i] = ec._ResourceConnection_edges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._ResourceConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._ResourceConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var resourceEdgeImplementors = []string{"ResourceEdge"}

func (ec *executionContext) _ResourceEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.ResourceEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceEdge")
		case "cursor":

			out.Values[i] = ec._ResourceEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":

			out.Values[i] = ec._ResourceEdge_node(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var resourcePoolImplementors = []string{"ResourcePool", "Node"}

func (ec *executionContext) _ResourcePool(ctx context.Context, sel ast.SelectionSet, obj *ent.ResourcePool) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourcePoolImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourcePool")
		case "AllocationStrategy":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ResourcePool_AllocationStrategy(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Capacity":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ResourcePool_Capacity(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Name":

			out.Values[i] = ec._ResourcePool_Name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ParentResource":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ResourcePool_ParentResource(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "PoolProperties":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ResourcePool_PoolProperties(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "PoolType":

			out.Values[i] = ec._ResourcePool_PoolType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "ResourceType":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ResourcePool_ResourceType(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Resources":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ResourcePool_Resources(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Tags":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ResourcePool_Tags(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "allocatedResources":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ResourcePool_allocatedResources(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "id":

			out.Values[i] = ec._ResourcePool_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var resourcePoolConnectionImplementors = []string{"ResourcePoolConnection"}

func (ec *executionContext) _ResourcePoolConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.ResourcePoolConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourcePoolConnectionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourcePoolConnection")
		case "edges":

			out.Values[i] = ec._ResourcePoolConnection_edges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pageInfo":

			out.Values[i] = ec._ResourcePoolConnection_pageInfo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalCount":

			out.Values[i] = ec._ResourcePoolConnection_totalCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var resourcePoolEdgeImplementors = []string{"ResourcePoolEdge"}

func (ec *executionContext) _ResourcePoolEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.ResourcePoolEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourcePoolEdgeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourcePoolEdge")
		case "cursor":

			out.Values[i] = ec._ResourcePoolEdge_cursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "node":

			out.Values[i] = ec._ResourcePoolEdge_node(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var resourceTypeImplementors = []string{"ResourceType", "Node"}

func (ec *executionContext) _ResourceType(ctx context.Context, sel ast.SelectionSet, obj *ent.ResourceType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceTypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceType")
		case "Name":

			out.Values[i] = ec._ResourceType_Name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "Pools":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ResourceType_Pools(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "PropertyTypes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ResourceType_PropertyTypes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "id":

			out.Values[i] = ec._ResourceType_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tagImplementors = []string{"Tag", "Node"}

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj *ent.Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Tag")
		case "Pools":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Tag_Pools(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "Tag":

			out.Values[i] = ec._Tag_Tag(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "id":

			out.Values[i] = ec._Tag_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tagPoolPayloadImplementors = []string{"TagPoolPayload"}

func (ec *executionContext) _TagPoolPayload(ctx context.Context, sel ast.SelectionSet, obj *model.TagPoolPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tagPoolPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TagPoolPayload")
		case "tag":

			out.Values[i] = ec._TagPoolPayload_tag(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var untagPoolPayloadImplementors = []string{"UntagPoolPayload"}

func (ec *executionContext) _UntagPoolPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UntagPoolPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, untagPoolPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UntagPoolPayload")
		case "tag":

			out.Values[i] = ec._UntagPoolPayload_tag(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateResourceTypeNamePayloadImplementors = []string{"UpdateResourceTypeNamePayload"}

func (ec *executionContext) _UpdateResourceTypeNamePayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateResourceTypeNamePayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateResourceTypeNamePayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateResourceTypeNamePayload")
		case "resourceTypeId":

			out.Values[i] = ec._UpdateResourceTypeNamePayload_resourceTypeId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var updateTagPayloadImplementors = []string{"UpdateTagPayload"}

func (ec *executionContext) _UpdateTagPayload(ctx context.Context, sel ast.SelectionSet, obj *model.UpdateTagPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateTagPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateTagPayload")
		case "tag":

			out.Values[i] = ec._UpdateTagPayload_tag(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAllocationStrategy2githubcomnetautoresourceManagerentAllocationStrategy(ctx context.Context, sel ast.SelectionSet, v ent.AllocationStrategy) graphql.Marshaler {
	return ec._AllocationStrategy(ctx, sel, &v)
}

func (ec *executionContext) marshalNAllocationStrategy2githubcomnetautoresourceManagerentAllocationStrategy(ctx context.Context, sel ast.SelectionSet, v []*ent.AllocationStrategy) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAllocationStrategy2githubcomnetautoresourceManagerentAllocationStrategy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAllocationStrategy2githubcomnetautoresourceManagerentAllocationStrategy(ctx context.Context, sel ast.SelectionSet, v *ent.AllocationStrategy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AllocationStrategy(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAllocationStrategyLang2githubcomnetautoresourceManagerentallocationstrategyLang(ctx context.Context, v interface{}) (allocationstrategy.Lang, error) {
	var res allocationstrategy.Lang
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAllocationStrategyLang2githubcomnetautoresourceManagerentallocationstrategyLang(ctx context.Context, sel ast.SelectionSet, v allocationstrategy.Lang) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCreateAllocatingPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateAllocatingPoolPayload(ctx context.Context, sel ast.SelectionSet, v model.CreateAllocatingPoolPayload) graphql.Marshaler {
	return ec._CreateAllocatingPoolPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateAllocatingPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateAllocatingPoolPayload(ctx context.Context, sel ast.SelectionSet, v *model.CreateAllocatingPoolPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateAllocatingPoolPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNCreateAllocationStrategyPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateAllocationStrategyPayload(ctx context.Context, sel ast.SelectionSet, v model.CreateAllocationStrategyPayload) graphql.Marshaler {
	return ec._CreateAllocationStrategyPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateAllocationStrategyPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateAllocationStrategyPayload(ctx context.Context, sel ast.SelectionSet, v *model.CreateAllocationStrategyPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateAllocationStrategyPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateNestedAllocatingPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedAllocatingPoolInput(ctx context.Context, v interface{}) (model.CreateNestedAllocatingPoolInput, error) {
	res, err := ec.unmarshalInputCreateNestedAllocatingPoolInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateNestedAllocatingPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedAllocatingPoolPayload(ctx context.Context, sel ast.SelectionSet, v model.CreateNestedAllocatingPoolPayload) graphql.Marshaler {
	return ec._CreateNestedAllocatingPoolPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateNestedAllocatingPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedAllocatingPoolPayload(ctx context.Context, sel ast.SelectionSet, v *model.CreateNestedAllocatingPoolPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateNestedAllocatingPoolPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateNestedSetPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedSetPoolInput(ctx context.Context, v interface{}) (model.CreateNestedSetPoolInput, error) {
	res, err := ec.unmarshalInputCreateNestedSetPoolInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateNestedSetPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedSetPoolPayload(ctx context.Context, sel ast.SelectionSet, v model.CreateNestedSetPoolPayload) graphql.Marshaler {
	return ec._CreateNestedSetPoolPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateNestedSetPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedSetPoolPayload(ctx context.Context, sel ast.SelectionSet, v *model.CreateNestedSetPoolPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateNestedSetPoolPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateNestedSingletonPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedSingletonPoolInput(ctx context.Context, v interface{}) (model.CreateNestedSingletonPoolInput, error) {
	res, err := ec.unmarshalInputCreateNestedSingletonPoolInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateNestedSingletonPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedSingletonPoolPayload(ctx context.Context, sel ast.SelectionSet, v model.CreateNestedSingletonPoolPayload) graphql.Marshaler {
	return ec._CreateNestedSingletonPoolPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateNestedSingletonPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateNestedSingletonPoolPayload(ctx context.Context, sel ast.SelectionSet, v *model.CreateNestedSingletonPoolPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateNestedSingletonPoolPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateResourceTypeInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateResourceTypeInput(ctx context.Context, v interface{}) (model.CreateResourceTypeInput, error) {
	res, err := ec.unmarshalInputCreateResourceTypeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateResourceTypePayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateResourceTypePayload(ctx context.Context, sel ast.SelectionSet, v model.CreateResourceTypePayload) graphql.Marshaler {
	return ec._CreateResourceTypePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateResourceTypePayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateResourceTypePayload(ctx context.Context, sel ast.SelectionSet, v *model.CreateResourceTypePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateResourceTypePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateSetPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateSetPoolInput(ctx context.Context, v interface{}) (model.CreateSetPoolInput, error) {
	res, err := ec.unmarshalInputCreateSetPoolInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateSetPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateSetPoolPayload(ctx context.Context, sel ast.SelectionSet, v model.CreateSetPoolPayload) graphql.Marshaler {
	return ec._CreateSetPoolPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateSetPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateSetPoolPayload(ctx context.Context, sel ast.SelectionSet, v *model.CreateSetPoolPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateSetPoolPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNCreateSingletonPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateSingletonPoolPayload(ctx context.Context, sel ast.SelectionSet, v model.CreateSingletonPoolPayload) graphql.Marshaler {
	return ec._CreateSingletonPoolPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateSingletonPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateSingletonPoolPayload(ctx context.Context, sel ast.SelectionSet, v *model.CreateSingletonPoolPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateSingletonPoolPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateTagInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateTagInput(ctx context.Context, v interface{}) (model.CreateTagInput, error) {
	res, err := ec.unmarshalInputCreateTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreateTagPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateTagPayload(ctx context.Context, sel ast.SelectionSet, v model.CreateTagPayload) graphql.Marshaler {
	return ec._CreateTagPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreateTagPayload2githubcomnetautoresourceManagergraphgraphqlmodelCreateTagPayload(ctx context.Context, sel ast.SelectionSet, v *model.CreateTagPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreateTagPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNDeleteAllocationStrategyPayload2githubcomnetautoresourceManagergraphgraphqlmodelDeleteAllocationStrategyPayload(ctx context.Context, sel ast.SelectionSet, v model.DeleteAllocationStrategyPayload) graphql.Marshaler {
	return ec._DeleteAllocationStrategyPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteAllocationStrategyPayload2githubcomnetautoresourceManagergraphgraphqlmodelDeleteAllocationStrategyPayload(ctx context.Context, sel ast.SelectionSet, v *model.DeleteAllocationStrategyPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteAllocationStrategyPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteResourcePoolInput2githubcomnetautoresourceManagergraphgraphqlmodelDeleteResourcePoolInput(ctx context.Context, v interface{}) (model.DeleteResourcePoolInput, error) {
	res, err := ec.unmarshalInputDeleteResourcePoolInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteResourcePoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelDeleteResourcePoolPayload(ctx context.Context, sel ast.SelectionSet, v model.DeleteResourcePoolPayload) graphql.Marshaler {
	return ec._DeleteResourcePoolPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteResourcePoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelDeleteResourcePoolPayload(ctx context.Context, sel ast.SelectionSet, v *model.DeleteResourcePoolPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteResourcePoolPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteResourceTypeInput2githubcomnetautoresourceManagergraphgraphqlmodelDeleteResourceTypeInput(ctx context.Context, v interface{}) (model.DeleteResourceTypeInput, error) {
	res, err := ec.unmarshalInputDeleteResourceTypeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteResourceTypePayload2githubcomnetautoresourceManagergraphgraphqlmodelDeleteResourceTypePayload(ctx context.Context, sel ast.SelectionSet, v model.DeleteResourceTypePayload) graphql.Marshaler {
	return ec._DeleteResourceTypePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteResourceTypePayload2githubcomnetautoresourceManagergraphgraphqlmodelDeleteResourceTypePayload(ctx context.Context, sel ast.SelectionSet, v *model.DeleteResourceTypePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteResourceTypePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteTagInput2githubcomnetautoresourceManagergraphgraphqlmodelDeleteTagInput(ctx context.Context, v interface{}) (model.DeleteTagInput, error) {
	res, err := ec.unmarshalInputDeleteTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteTagPayload2githubcomnetautoresourceManagergraphgraphqlmodelDeleteTagPayload(ctx context.Context, sel ast.SelectionSet, v model.DeleteTagPayload) graphql.Marshaler {
	return ec._DeleteTagPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteTagPayload2githubcomnetautoresourceManagergraphgraphqlmodelDeleteTagPayload(ctx context.Context, sel ast.SelectionSet, v *model.DeleteTagPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteTagPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalIntID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalIntID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v interface{}) ([]map[string]interface{}, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]map[string]interface{}, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOMap2map(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v []map[string]interface{}) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOMap2map(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v interface{}) ([]map[string]interface{}, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]map[string]interface{}, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMap2map(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v []map[string]interface{}) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNMap2map(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOutputCursor2githubcomnetautoresourceManagerentCursor(ctx context.Context, sel ast.SelectionSet, v ent.Cursor) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2githubcomnetautoresourceManagerentPageInfo(ctx context.Context, sel ast.SelectionSet, v ent.PageInfo) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNPoolCapacityPayload2githubcomnetautoresourceManagergraphgraphqlmodelPoolCapacityPayload(ctx context.Context, sel ast.SelectionSet, v model.PoolCapacityPayload) graphql.Marshaler {
	return ec._PoolCapacityPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNPoolCapacityPayload2githubcomnetautoresourceManagergraphgraphqlmodelPoolCapacityPayload(ctx context.Context, sel ast.SelectionSet, v *model.PoolCapacityPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PoolCapacityPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPoolType2githubcomnetautoresourceManagerentresourcepoolPoolType(ctx context.Context, v interface{}) (resourcepool.PoolType, error) {
	var res resourcepool.PoolType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPoolType2githubcomnetautoresourceManagerentresourcepoolPoolType(ctx context.Context, sel ast.SelectionSet, v resourcepool.PoolType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPoolType2githubcomnetautoresourceManagerentresourcepoolPoolType(ctx context.Context, v interface{}) ([]resourcepool.PoolType, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]resourcepool.PoolType, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPoolType2githubcomnetautoresourceManagerentresourcepoolPoolType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNPoolType2githubcomnetautoresourceManagerentresourcepoolPoolType(ctx context.Context, sel ast.SelectionSet, v []resourcepool.PoolType) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPoolType2githubcomnetautoresourceManagerentresourcepoolPoolType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPropertyType2githubcomnetautoresourceManagerentPropertyType(ctx context.Context, sel ast.SelectionSet, v []*ent.PropertyType) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPropertyType2githubcomnetautoresourceManagerentPropertyType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPropertyType2githubcomnetautoresourceManagerentPropertyType(ctx context.Context, sel ast.SelectionSet, v *ent.PropertyType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PropertyType(ctx, sel, v)
}

func (ec *executionContext) marshalNResource2githubcomnetautoresourceManagerentResource(ctx context.Context, sel ast.SelectionSet, v ent.Resource) graphql.Marshaler {
	return ec._Resource(ctx, sel, &v)
}

func (ec *executionContext) marshalNResource2githubcomnetautoresourceManagerentResource(ctx context.Context, sel ast.SelectionSet, v []*ent.Resource) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNResource2githubcomnetautoresourceManagerentResource(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNResource2githubcomnetautoresourceManagerentResource(ctx context.Context, sel ast.SelectionSet, v *ent.Resource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Resource(ctx, sel, v)
}

func (ec *executionContext) marshalNResourceConnection2githubcomnetautoresourceManagerentResourceConnection(ctx context.Context, sel ast.SelectionSet, v ent.ResourceConnection) graphql.Marshaler {
	return ec._ResourceConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNResourceConnection2githubcomnetautoresourceManagerentResourceConnection(ctx context.Context, sel ast.SelectionSet, v *ent.ResourceConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNResourceEdge2githubcomnetautoresourceManagerentResourceEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.ResourceEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOResourceEdge2githubcomnetautoresourceManagerentResourceEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNResourceInput2githubcomnetautoresourceManagergraphgraphqlmodelResourceInput(ctx context.Context, v interface{}) ([]*model.ResourceInput, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.ResourceInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNResourceInput2githubcomnetautoresourceManagergraphgraphqlmodelResourceInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNResourceInput2githubcomnetautoresourceManagergraphgraphqlmodelResourceInput(ctx context.Context, v interface{}) (*model.ResourceInput, error) {
	res, err := ec.unmarshalInputResourceInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx context.Context, sel ast.SelectionSet, v ent.ResourcePool) graphql.Marshaler {
	return ec._ResourcePool(ctx, sel, &v)
}

func (ec *executionContext) marshalNResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx context.Context, sel ast.SelectionSet, v []*ent.ResourcePool) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx context.Context, sel ast.SelectionSet, v *ent.ResourcePool) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourcePool(ctx, sel, v)
}

func (ec *executionContext) marshalNResourcePoolConnection2githubcomnetautoresourceManagerentResourcePoolConnection(ctx context.Context, sel ast.SelectionSet, v ent.ResourcePoolConnection) graphql.Marshaler {
	return ec._ResourcePoolConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNResourcePoolConnection2githubcomnetautoresourceManagerentResourcePoolConnection(ctx context.Context, sel ast.SelectionSet, v *ent.ResourcePoolConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourcePoolConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNResourcePoolEdge2githubcomnetautoresourceManagerentResourcePoolEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.ResourcePoolEdge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOResourcePoolEdge2githubcomnetautoresourceManagerentResourcePoolEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNResourcePoolInput2githubcomnetautoresourceManagergraphgraphqlmodelResourcePoolInput(ctx context.Context, v interface{}) (model.ResourcePoolInput, error) {
	res, err := ec.unmarshalInputResourcePoolInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResourceType2githubcomnetautoresourceManagerentResourceType(ctx context.Context, sel ast.SelectionSet, v []*ent.ResourceType) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNResourceType2githubcomnetautoresourceManagerentResourceType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNResourceType2githubcomnetautoresourceManagerentResourceType(ctx context.Context, sel ast.SelectionSet, v *ent.ResourceType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ResourceType(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTag2githubcomnetautoresourceManagerentTag(ctx context.Context, sel ast.SelectionSet, v []*ent.Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2githubcomnetautoresourceManagerentTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTag2githubcomnetautoresourceManagerentTag(ctx context.Context, sel ast.SelectionSet, v *ent.Tag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTagAnd2githubcomnetautoresourceManagergraphgraphqlmodelTagAnd(ctx context.Context, v interface{}) ([]*model.TagAnd, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.TagAnd, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTagAnd2githubcomnetautoresourceManagergraphgraphqlmodelTagAnd(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNTagAnd2githubcomnetautoresourceManagergraphgraphqlmodelTagAnd(ctx context.Context, v interface{}) (*model.TagAnd, error) {
	res, err := ec.unmarshalInputTagAnd(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTagPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelTagPoolInput(ctx context.Context, v interface{}) (model.TagPoolInput, error) {
	res, err := ec.unmarshalInputTagPoolInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelTagPoolPayload(ctx context.Context, sel ast.SelectionSet, v model.TagPoolPayload) graphql.Marshaler {
	return ec._TagPoolPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNTagPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelTagPoolPayload(ctx context.Context, sel ast.SelectionSet, v *model.TagPoolPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TagPoolPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUntagPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelUntagPoolInput(ctx context.Context, v interface{}) (model.UntagPoolInput, error) {
	res, err := ec.unmarshalInputUntagPoolInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUntagPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelUntagPoolPayload(ctx context.Context, sel ast.SelectionSet, v model.UntagPoolPayload) graphql.Marshaler {
	return ec._UntagPoolPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUntagPoolPayload2githubcomnetautoresourceManagergraphgraphqlmodelUntagPoolPayload(ctx context.Context, sel ast.SelectionSet, v *model.UntagPoolPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UntagPoolPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateResourceTypeNameInput2githubcomnetautoresourceManagergraphgraphqlmodelUpdateResourceTypeNameInput(ctx context.Context, v interface{}) (model.UpdateResourceTypeNameInput, error) {
	res, err := ec.unmarshalInputUpdateResourceTypeNameInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateResourceTypeNamePayload2githubcomnetautoresourceManagergraphgraphqlmodelUpdateResourceTypeNamePayload(ctx context.Context, sel ast.SelectionSet, v model.UpdateResourceTypeNamePayload) graphql.Marshaler {
	return ec._UpdateResourceTypeNamePayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateResourceTypeNamePayload2githubcomnetautoresourceManagergraphgraphqlmodelUpdateResourceTypeNamePayload(ctx context.Context, sel ast.SelectionSet, v *model.UpdateResourceTypeNamePayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateResourceTypeNamePayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateTagInput2githubcomnetautoresourceManagergraphgraphqlmodelUpdateTagInput(ctx context.Context, v interface{}) (model.UpdateTagInput, error) {
	res, err := ec.unmarshalInputUpdateTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUpdateTagPayload2githubcomnetautoresourceManagergraphgraphqlmodelUpdateTagPayload(ctx context.Context, sel ast.SelectionSet, v model.UpdateTagPayload) graphql.Marshaler {
	return ec._UpdateTagPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNUpdateTagPayload2githubcomnetautoresourceManagergraphgraphqlmodelUpdateTagPayload(ctx context.Context, sel ast.SelectionSet, v *model.UpdateTagPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UpdateTagPayload(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAllocationStrategy2githubcomnetautoresourceManagerentAllocationStrategy(ctx context.Context, sel ast.SelectionSet, v *ent.AllocationStrategy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AllocationStrategy(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOCreateAllocatingPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateAllocatingPoolInput(ctx context.Context, v interface{}) (*model.CreateAllocatingPoolInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateAllocatingPoolInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateAllocationStrategyInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateAllocationStrategyInput(ctx context.Context, v interface{}) (*model.CreateAllocationStrategyInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateAllocationStrategyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCreateSingletonPoolInput2githubcomnetautoresourceManagergraphgraphqlmodelCreateSingletonPoolInput(ctx context.Context, v interface{}) (*model.CreateSingletonPoolInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCreateSingletonPoolInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCursor2githubcomnetautoresourceManagerentCursor(ctx context.Context, v interface{}) (*ent.Cursor, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(ent.Cursor)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2githubcomnetautoresourceManagerentCursor(ctx context.Context, sel ast.SelectionSet, v *ent.Cursor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalODeleteAllocationStrategyInput2githubcomnetautoresourceManagergraphgraphqlmodelDeleteAllocationStrategyInput(ctx context.Context, v interface{}) (*model.DeleteAllocationStrategyInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDeleteAllocationStrategyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOID2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalIntID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalIntID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) marshalONode2githubcomnetautoresourceManagerentNoder(ctx context.Context, sel ast.SelectionSet, v ent.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalOOutputCursor2githubcomnetautoresourceManagerentCursor(ctx context.Context, sel ast.SelectionSet, v *ent.Cursor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOPoolCapacityPayload2githubcomnetautoresourceManagergraphgraphqlmodelPoolCapacityPayload(ctx context.Context, sel ast.SelectionSet, v *model.PoolCapacityPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PoolCapacityPayload(ctx, sel, v)
}

func (ec *executionContext) marshalOResource2githubcomnetautoresourceManagerentResource(ctx context.Context, sel ast.SelectionSet, v *ent.Resource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Resource(ctx, sel, v)
}

func (ec *executionContext) marshalOResourceConnection2githubcomnetautoresourceManagerentResourceConnection(ctx context.Context, sel ast.SelectionSet, v *ent.ResourceConnection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ResourceConnection(ctx, sel, v)
}

func (ec *executionContext) marshalOResourceEdge2githubcomnetautoresourceManagerentResourceEdge(ctx context.Context, sel ast.SelectionSet, v *ent.ResourceEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ResourceEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx context.Context, sel ast.SelectionSet, v []*ent.ResourcePool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOResourcePool2githubcomnetautoresourceManagerentResourcePool(ctx context.Context, sel ast.SelectionSet, v *ent.ResourcePool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ResourcePool(ctx, sel, v)
}

func (ec *executionContext) marshalOResourcePoolEdge2githubcomnetautoresourceManagerentResourcePoolEdge(ctx context.Context, sel ast.SelectionSet, v *ent.ResourcePoolEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ResourcePoolEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTag2githubcomnetautoresourceManagerentTag(ctx context.Context, sel ast.SelectionSet, v *ent.Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTagOr2githubcomnetautoresourceManagergraphgraphqlmodelTagOr(ctx context.Context, v interface{}) (*model.TagOr, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTagOr(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
