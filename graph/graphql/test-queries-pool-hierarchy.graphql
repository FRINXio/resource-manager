# Test pool hierarchies
# Creates following hierarchy of ipv4 prefixes with ips at the end

#                                            +---------------------------+
#                                           |                           |
#                                           |  Name: 10.0.0.0/8         |
#                                           |  Type: Ipv4Prefix         |
#                                           |  Allocation strategy:     |
#                                           |   split_ipv4_prefix_in_2  |
#                                           |                           |
#                                           +--------------+------------+
#                                                          |
#                                                          |
#                                +-------------------------+------------------------------+
#                                |                                                        |
#                                |                                                        |
#                 +--------------+------------+                        +------------------+----------------+
#                 |                           |                        |                                   |
#                 |  Name: 10.0.0.0/9         |                        |  Name: 10.128.0.0/9               |
#                 |  Type: Ipv4Prefix         |                        |  Type: Ipv4Prefix                 |
#                 |  Allocation strategy:     |                        |  Set:                             |
#                 |   split_ipv4_prefix_in_2  |                        |   [10.128.0.0/10, 10.192.0.0/10]  |
#                 |                           |                        |                                   |
#                 +-------------+-------------+                        +------------------+----------------+
#                               |                                                         |
#                               |                                                         |
#              +----------------+----------------+                                    +---+----------------------------------+
#              |                                 |                                    |                                      |
#              |                                 |                                    |                                      |
#+-------------+-------------+     +-------------+-------------+       +--------------+------------+           +-------------+-------------+
#|                           |     |                           |       |                           |           |                           |
#|  Name: 10.0.0.0/10        |     |  Name: 10.64.0.0/10       |       |  Name: 10.128.0.0/10      |           |  Name: 10.192.0.0/10      |
#|  Type: Ipv4Prefix         |     |  Type: Ipv4               |       |  Type: Ipv4               |           |  Type: Ipv4               |
#|  Singleton: 10.0.0.0/11   |     |  Allocation strategy:     |       |  Allocation strategy:     |           |  Allocation strategy:     |
#|                           |     |   ipv4_from_subnet        |       |   ipv4_from_subnet        |           |   ipv4_from_subnet        |
#|         # Unused          |     |                           |       |                           |           |                           |
#+---------------------------+     +---------------------------+       +---------------------------+           +---------------------------+

mutation createResourceType_ipv4Prefix {
    CreateResourceType(
        resourceName: "ipv4_prefix",
        resourceProperties: {
            address: "string",
            prefix: "int"
        }
    ) {
        ID
    }
}

mutation CreateIpv4PrefixAllocationStratJs {
    CreateAllocationStrategy(
        name: "ipv4_prefix_splitting_in_2",
        description: "This strategy can split a network prefix into 2 new prefixes equally sized"
        script: """

       /*
IPv4 prefix allocation strategy

- Expects IPv4 prefix resource type to have 2 properties of type int ["address:string", "mask:int"]
- userInput.desiredSize is a required parameter e.g. desiredSize == 10  ---produces-prefix-of--->  192.168.1.0/28
- userInput.subnet is an optional parameter specifying whether allocated prefix will be used as a real subnet or just
  as an IP pool. Essentially whether to count subnet address and broadcast into the range or not. If set to true, the resulting
  prefix will have a capacity of desiredSize + 2. Defaults to false
- Logs utilisation stats
- Allocates previously freed prefixes
- All addresses from parent prefix are used, including the first and last one
 */

// ipv4 int to str
function inet_ntoa(addrint) {
    return ((addrint >> 24) & 0xff) + "." +
        ((addrint >> 16) & 0xff) + "." +
        ((addrint >> 8) & 0xff) + "." +
        (addrint & 0xff)
}

// ipv4 str to int
function inet_aton(addrstr) {
    var re = /^([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/
    var res = re.exec(addrstr)

    if (res === null) {
        console.error("Address is invalid, doesnt match regex: " + re)
        return null
    }

    for (var i = 1; i <= 4; i++) {
        if (res[i] < 0 || res[i] > 255) {
            console.error("Address is invalid, outside of ipv4 range: " + addrstr)
            return null
        }
    }

    return (res[1] << 24) | (res[2] << 16) | (res[3] << 8) | res[4]
}

// number of addresses in a subnet based on its mask
function subnetAddresses(mask) {
    return 1<<(32-mask)
}

// TODO code reuse between strategies

const prefixRegex = /([0-9.]+)\/([0-9]{1,2})/

// parse prefix from a string e.g. 1.2.3.4/18 into an object
function parsePrefix(str) {
    let res = prefixRegex.exec(str)
    if (res == null) {
        console.error("Prefix is invalid, doesnt match regex: " + prefixRegex)
        return null
    }

    let addrNum = inet_aton(res[1])
    if (addrNum == null) {
        return null
    }

    let mask = parseInt(res[2], 10)
    if (mask < 0 || mask > 32) {
        console.error("Mask is invalid outside of ipv4 range: " + mask)
        return null
    }

    if (mask === 0) {
        addrNum = 0
    } else {
        // making sure to nullify any bits set to 1 in subnet addr outside of mask
        addrNum = (addrNum >>> (32-mask)) << (32-mask)
    }

    return {
        "address": inet_ntoa(addrNum),
        "prefix": mask
    }
}

// compare prefixes based on their broadcast address
function comparePrefix(prefix1, prefix2) {
    let endOfP1 = inet_aton(prefix1.address) + subnetAddresses(prefix1.prefix)
    let endOfP2 = inet_aton(prefix2.address) + subnetAddresses(prefix2.prefix)
    return endOfP1 - endOfP2
}

// sum up capacity of an array of addresses
function prefixesCapacity(currentResources) {
    let width = 0
    for (let allocatedPrefix of currentResources) {
        width += subnetAddresses(allocatedPrefix.prefix)
    }
    return width
}

// calculate utilized capacity based on previously allocated prefixes + a newly allocated prefix
function utilizedCapacity(allocatedRanges, newlyAllocatedRangeCapacity) {
    return prefixesCapacity(allocatedRanges) + newlyAllocatedRangeCapacity
}

// calculate free capacity based on previously allocated prefixes
function freeCapacity(parentPrefix, utilisedCapacity) {
    return subnetAddresses(parentPrefix.prefix) - utilisedCapacity
}

// log utilisation stats
function logStats(newlyAllocatedPrefix, parentRange, allocatedPrefixes = [], level = "log") {
    let newlyAllocatedPrefixCapacity = 0
    if (newlyAllocatedPrefix) {
        newlyAllocatedPrefixCapacity = subnetAddresses(newlyAllocatedPrefix.prefix)
    } else {
        newlyAllocatedPrefixCapacity = 0
    }

    let utilisedCapacity = utilizedCapacity(allocatedPrefixes, newlyAllocatedPrefixCapacity)
    let remainingCapacity = freeCapacity(parentRange, utilisedCapacity)
    let utilPercentage
    if (remainingCapacity === 0) {
        utilPercentage = 100.0
    } else {
        utilPercentage = (utilisedCapacity / subnetAddresses(parentRange.prefix)) * 100
    }
    console[level]("Remaining capacity: " + remainingCapacity)
    console[level]("Utilised capacity: " + utilisedCapacity)
    console[level](`Utilisation: ${utilPercentage.toFixed(1)}%`)
}

function prefixesToString(currentResourcesUnwrapped) {
    let prefixesToStr = ""
    for (let allocatedPrefix of currentResourcesUnwrapped) {
        prefixesToStr += prefixToStr(allocatedPrefix)
        prefixesToStr += prefixToRangeStr(allocatedPrefix)
        prefixesToStr += ", "
    }
    return prefixesToStr
}

function prefixToStr(prefix) {
    return `${prefix.address}/${prefix.prefix}`
}

function prefixToRangeStr(prefix) {
    return `[${prefix.address}-${inet_ntoa(inet_aton(prefix.address) + subnetAddresses(prefix.prefix) - 1)}]`
}

function calculateDesiredSubnetMask() {
    let newSubnetBits = Math.ceil(Math.log(userInput.desiredSize) / Math.log(2))
    let newSubnetMask = 32 - newSubnetBits
    let newSubnetCapacity = subnetAddresses(newSubnetMask)
    return {newSubnetMask, newSubnetCapacity};
}

// calculate the nearest possible address for a subnet where mask === newSubnetMask
//  that is outside of allocatedSubnet
function findNextFreeSubnetAddress(allocatedSubnet, newSubnetMask) {
    // find the first address after currently iterated allocated subnet
    let nextAvailableAddressNum = inet_aton(allocatedSubnet.address) + subnetAddresses(allocatedSubnet.prefix)
    // remove any bites from the address above after newSubnetMask
    let newSubnetMaskNegative = 32 - newSubnetMask
    let possibleSubnetNum = (nextAvailableAddressNum >>> newSubnetMaskNegative) << newSubnetMaskNegative
    // keep going until we find an address outside of currently iterated allocated subnet
    while (nextAvailableAddressNum > possibleSubnetNum) {
        possibleSubnetNum = ((possibleSubnetNum >>> newSubnetMaskNegative) + 1) << newSubnetMaskNegative
    }
    return possibleSubnetNum;
}

// main
function invoke() {
    let rootPrefix = resourcePool.ResourcePoolName

    let rootPrefixParsed = parsePrefix(rootPrefix)
    if (rootPrefixParsed == null) {
        console.error("Unable to extract root prefix from pool name: " + rootPrefix)
        return null
    }
    let rootAddressStr = rootPrefixParsed.address
    let rootMask = rootPrefixParsed.prefix
    let rootPrefixStr = prefixToStr(rootPrefixParsed)
    let rootCapacity = subnetAddresses(rootMask)
    let rootAddressNum = inet_aton(rootAddressStr)

    if (!userInput.desiredSize) {
        console.error("Unable to allocate subnet from root prefix: " + rootPrefixStr +
            ". Desired size of a new subnet size not provided as userInput.desiredSize")
        return null
    }

    if (userInput.desiredSize < 2) {
        console.error("Unable to allocate subnet from root prefix: " + rootPrefixStr +
            ". Desired size is invalid: " + userInput.desiredSize + ". Use values >= 2")
        return null
    }

    if (userInput.subnet === true) {
        // reserve subnet address and broadcast
        userInput.desiredSize += 2
    }

    // Calculate smallest possible subnet mask to fit desiredSize
    let {newSubnetMask, newSubnetCapacity} = calculateDesiredSubnetMask();

    // unwrap and sort currentResources
    currentResourcesUnwrapped = currentResources.map(cR => cR.Properties)
    currentResourcesUnwrapped.sort(comparePrefix)

    let possibleSubnetNum = rootAddressNum
    // iterate over allocated subnets and see if a desired new subnet can be squeezed in
    for (let allocatedSubnet of currentResourcesUnwrapped) {

        let allocatedSubnetNum = inet_aton(allocatedSubnet.address)
        let chunkCapacity = allocatedSubnetNum - possibleSubnetNum
        if (chunkCapacity >= userInput.desiredSize) {
            // there is chunk with sufficient capacity between possibleSubnetNum and allocatedSubnet.address
            let newlyAllocatedPrefix = {
                "address": inet_ntoa(possibleSubnetNum),
                "prefix": newSubnetMask
            }
            // FIXME How to pass these stats ?
            // logStats(newlyAllocatedPrefix, rootPrefixParsed, currentResourcesUnwrapped)
            return newlyAllocatedPrefix
        }

        // move possible subnet start to a valid address outside of allocatedSubnets addresses and continue the search
        possibleSubnetNum = findNextFreeSubnetAddress(allocatedSubnet, newSubnetMask);
    }

    // check if there is any space left at the end of parent range
    if (possibleSubnetNum + newSubnetCapacity <= rootAddressNum + rootCapacity) {
        // there sure is some space, use it !
        let newlyAllocatedPrefix = {
            "address": inet_ntoa(possibleSubnetNum),
            "prefix": newSubnetMask
        }
        // FIXME How to pass these stats ?
        // logStats(newlyAllocatedPrefix, rootPrefixParsed, currentResourcesUnwrapped)
        return newlyAllocatedPrefix
    }

    // no suitable range found
    console.error("Unable to allocate Ipv4 prefix from: " + rootPrefixStr +
        ". Insufficient capacity to allocate a new prefix of size: " + userInput.desiredSize)
    console.error("Currently allocated prefixes: " + prefixesToString(currentResourcesUnwrapped))
    logStats(null, rootPrefixParsed, currentResourcesUnwrapped, "error")
    return null
}

        """,
        lang: js
    ){
        ID
    }
}

mutation TestAllocationStrat_ipv4Prefix {
    TestAllocationStrategy(
        allocationStrategyId: 1,
        resourcePool: { ResourcePoolName: "10.0.0.0/8"},
        currentResources: [],
        userInput: {desiredSize: 8388608})
}

mutation TestAllocationStrat_ipv4Prefix_2 {
    TestAllocationStrategy(
        allocationStrategyId: 1,
        resourcePool: { ResourcePoolName: "10.0.0.0/8"},
        currentResources: [{Properties: { prefix: 9, address: "10.0.0.0"},
            Status: "claimed",
            UpdatedAt: "2020-08-18 11:38:48.0 +0200 CEST"
        }],
        userInput: {desiredSize: 8388608})
}

mutation TestAllocationStrat_ipv4Prefix_full {
    TestAllocationStrategy(
        allocationStrategyId: 1,
        resourcePool: { ResourcePoolName: "10.0.0.0/8"},
        currentResources: [
            {Properties: { prefix: 9, address: "10.0.0.0"},
                Status: "claimed",
                UpdatedAt: "2020-08-18 11:38:48.0 +0200 CEST"
            },
            {Properties: { prefix: 9, address: "10.128.0.0"},
                Status: "claimed",
                UpdatedAt: "2020-08-18 11:38:48.0 +0200 CEST"
            }],
        userInput: {desiredSize: 2})
}

mutation createResourceType_ipv4Address {
    CreateResourceType(
        resourceName: "ipv4_address",
        resourceProperties: {
            address: "string",
        }
    ) {
        ID
    }
}

mutation CreateIpv4AddressAllocationStratJs {
    CreateAllocationStrategy(
        name: "ipv4_address_from_subnet",
        description: "This strategy allocates ipv4 addresses from a subnet represented by a prefix"
        script: """

/*
IPv4 prefix allocation strategy

- Expects IPv4 prefix resource type to have 2 properties of type int ["address:string", "mask:int"]
- userInput.subnet is an optional parameter specifying whether root prefix will be used as a real subnet or just
  as an IP pool. Essentially whether to consider subnet address and broadcast when allocating addresses.
- Logs utilisation stats
- Allocates previously freed prefixes
- All addresses from parent prefix are used, including the first and last one
 */

// ipv4 int to str
function inet_ntoa(addrint) {
    return ((addrint >> 24) & 0xff) + "." +
        ((addrint >> 16) & 0xff) + "." +
        ((addrint >> 8) & 0xff) + "." +
        (addrint & 0xff)
}

// ipv4 str to int
function inet_aton(addrstr) {
    var re = /^([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/
    var res = re.exec(addrstr)

    if (res === null) {
        console.error("Address: " + addrstr + " is invalid, doesnt match regex: " + re)
        return null
    }

    for (var i = 1; i <= 4; i++) {
        if (res[i] < 0 || res[i] > 255) {
            console.error("Address: " + addrstr + " is invalid, outside of ipv4 range: " + addrstr)
            return null
        }
    }

    return (res[1] << 24) | (res[2] << 16) | (res[3] << 8) | res[4]
}

// number of addresses in a subnet based on its mask
function subnetAddresses(mask) {
    return 1<<(32-mask)
}

const prefixRegex = /([0-9.]+)\/([0-9]{1,2})/

// parse prefix from a string e.g. 1.2.3.4/18 into an object
function parsePrefix(str) {
    let res = prefixRegex.exec(str)
    if (res == null) {
        console.error("Prefix is invalid, doesnt match regex: " + prefixRegex)
        return null
    }

    let addrNum = inet_aton(res[1])
    if (addrNum == null) {
        return null
    }

    let mask = parseInt(res[2], 10)
    if (mask < 0 || mask > 32) {
        console.error("Mask is invalid outside of ipv4 range: " + mask)
        return null
    }

    if (mask === 0) {
        addrNum = 0
    } else {
        // making sure to nullify any bits set to 1 in subnet addr outside of mask
        addrNum = (addrNum >>> (32-mask)) << (32-mask)
    }

    return {
        "address": inet_ntoa(addrNum),
        "prefix": mask
    }
}

// compare prefixes based on their broadcast address
function compareAddresses(addr1, addr2) {
    return inet_aton(addr1.address) - inet_aton(addr2.address)
}

// calculate utilized capacity based on previously allocated prefixes + a newly allocated prefix
function utilizedCapacity(allocatedRanges, newlyAllocatedRangeCapacity) {
    return allocatedRanges.length + newlyAllocatedRangeCapacity
}

// calculate free capacity based on previously allocated prefixes
function freeCapacity(parentPrefix, utilisedCapacity) {
    return subnetAddresses(parentPrefix.prefix) - utilisedCapacity
}

// log utilisation stats
function logStats(newlyAllocatedAddr, parentRange, isSubnet = false, allocatedAddresses = [], level = "log") {
    let newlyAllocatedPrefixCapacity = 0
    if (newlyAllocatedAddr) {
        newlyAllocatedPrefixCapacity = 1
    } else {
        newlyAllocatedPrefixCapacity = 0
    }

    let utilisedCapacity = utilizedCapacity(allocatedAddresses, newlyAllocatedPrefixCapacity)
    if(isSubnet) {
        utilisedCapacity += 2
    }
    let remainingCapacity = freeCapacity(parentRange, utilisedCapacity)
    let utilPercentage
    if (remainingCapacity === 0) {
        utilPercentage = 100.0
    } else {
        utilPercentage = (utilisedCapacity / subnetAddresses(parentRange.prefix)) * 100
    }
    console[level]("Remaining capacity: " + remainingCapacity)
    console[level]("Utilised capacity: " + utilisedCapacity)
    console[level](`Utilisation: ${utilPercentage.toFixed(1)}%`)
}

function addressesToStr(currentResourcesUnwrapped) {
    let addressesToStr = ""
    for (let allocatedAddr of currentResourcesUnwrapped) {
        addressesToStr += allocatedAddr.address
        addressesToStr += ", "
    }
    return addressesToStr
}

function prefixToStr(prefix) {
    return `${prefix.address}/${prefix.prefix}`
}

// main
function invoke() {
    let rootPrefix = resourcePool.ResourcePoolName

    let rootPrefixParsed = parsePrefix(rootPrefix)
    if (rootPrefixParsed == null) {
        console.error("Unable to extract root prefix from pool name: " + rootPrefix)
        return null
    }
    let rootAddressStr = rootPrefixParsed.address
    let rootMask = rootPrefixParsed.prefix
    let rootPrefixStr = prefixToStr(rootPrefixParsed)
    let rootCapacity = subnetAddresses(rootMask)
    let rootAddressNum = inet_aton(rootAddressStr)

    // unwrap and sort currentResources
    currentResourcesUnwrapped = currentResources.map(cR => cR.Properties)
    let currentResourcesSet = new Set(currentResourcesUnwrapped.map(ip => ip.address))

    let firstPossibleAddr = 0
    let lastPossibleAddr = 0
    if (userInput.subnet === true) {
        firstPossibleAddr = rootAddressNum + 1
        lastPossibleAddr = rootAddressNum + rootCapacity - 1
    } else {
        firstPossibleAddr = rootAddressNum
        lastPossibleAddr = rootAddressNum + rootCapacity
    }

    for (let i = firstPossibleAddr; i < lastPossibleAddr; i++) {
        if (!currentResourcesSet.has(inet_ntoa(i))) {
            // FIXME How to pass these stats ?
            // logStats(inet_ntoa(i), rootPrefixParsed, userInput.subnet === true, currentResourcesUnwrapped)
            return {
                "address": inet_ntoa(i)
            }
        }
    }

    // no suitable range found
    console.error("Unable to allocate Ipv4 address from: " + rootPrefixStr +
        ". Insufficient capacity to allocate a new address")
    console.error("Currently allocated addresses: " + addressesToStr(currentResourcesUnwrapped))
    logStats(null, rootPrefixParsed, userInput.subnet === true, currentResourcesUnwrapped, "error")
    return null
}
        """,
        lang: js
    ){
        ID
    }
}

mutation TestIpv4AddrAllocationStrat_1 {
    TestAllocationStrategy(
        allocationStrategyId: 2,
        resourcePool: { ResourcePoolName: "10.0.0.0/8"},
        currentResources: [],
        userInput: {})
}

# Root pool
mutation CreateRootPool_allocating {
    CreateAllocatingPool(input: {
        resourceTypeId: 21474836480,
        poolName: "10.0.0.0/8",
        allocationStrategyId: 1,
        poolDealocationSafetyPeriod: 0}
    ){
        ID
    }
}

# Pool 10.0.0.0/9 on level #2
mutation ClaimResourceFromRoot {
    ClaimResource(poolId:17179869184, userInput: {desiredSize: 8388608}) {
        ID
        Properties
    }
}

mutation CreateLevel2Pool1_allocating {
    CreateNestedAllocatingPool(input: {
        resourceTypeId: 21474836480,
        poolName: "10.0.0.0/9",
        allocationStrategyId: 1,
        poolDealocationSafetyPeriod: 0},
        parentResourceId: 12884901888
    ){
        ID
    }
}

# Pool 10.128.0.0/9 on level #2
mutation ClaimResourceFromRoot {
    ClaimResource(poolId:17179869184, userInput: {desiredSize: 8388608}) {
        ID
        Properties
    }
}

mutation CreateLevel2Pool2_set {
    CreateNestedSetPool(input: {
        resourceTypeId: 21474836480,
        poolName: "10.128.0.0/9",
        poolValues: [{address: "10.128.0.0", prefix: 10}, {address: "10.192.0.0", prefix: 10},],
        poolDealocationSafetyPeriod: 0},
        parentResourceId: 12884901889
    ){
        ID
    }
}

# Pool 10.0.0.0/10 on level #3
mutation ClaimResourceFromLevel2Pool1 {
    ClaimResource(poolId:17179869185, userInput: {desiredSize: 4194304}) {
        ID
        Properties
    }
}

mutation CreateLevel3Pool1_singleton {
    CreateNestedSingletonPool(input: {
        resourceTypeId: 21474836480,
        poolName: "10.0.0.0/10",
        poolValues: [{address: "10.10.0.0", prefix: 11},]},
        parentResourceId: 12884901892
    ){
        ID
    }
}

# Pool 10.64.0.0/10 on level #3
mutation ClaimResourceFromLevel2Pool1 {
    ClaimResource(poolId:17179869185, userInput: {desiredSize: 4194304}) {
        ID
        Properties
    }
}

mutation CreateLevel2Pool1_allocating {
    CreateNestedAllocatingPool(input: {
        resourceTypeId: 21474836481,
        poolName: "10.64.0.0/10",
        allocationStrategyId: 2,
        poolDealocationSafetyPeriod: 0},
        parentResourceId: 12884901894
    ){
        ID
    }
}

mutation ClaimResourceFromLevel3Pool2_ips_from_10_64_0_0__10 {
    ClaimResource(poolId:17179869188, userInput: {}) {
        ID
        Properties
    }
}

# Pool 10.128.0.0/10 on level #3
mutation ClaimResourceFromLevel2Pool2 {
    ClaimResource(poolId:17179869186, userInput: {}) {
        ID
        Properties
    }
}

mutation CreateLevel3Pool3_allocating {
    CreateNestedAllocatingPool(input: {
        resourceTypeId: 21474836481,
        poolName: "10.128.0.0/10",
        allocationStrategyId: 2,
        poolDealocationSafetyPeriod: 0},
        parentResourceId: 12884901890
    ){
        ID
    }
}

mutation ClaimResourceFromLevel3Pool2_ips_from_10_128_0_0__10 {
    ClaimResource(poolId:17179869189, userInput: {}) {
        ID
        Properties
    }
}

# Pool 10.192.0.0/10 on level #3
mutation ClaimResourceFromLevel2Pool2 {
    ClaimResource(poolId:17179869186, userInput: {}) {
        ID
        Properties
    }
}

mutation CreateLevel3Pool3_allocating {
    CreateNestedAllocatingPool(input: {
        resourceTypeId: 21474836481,
        poolName: "10.192.0.0/10",
        allocationStrategyId: 2,
        poolDealocationSafetyPeriod: 0},
        parentResourceId: 12884901891
    ){
        ID
    }
}

mutation ClaimResourceFromLevel3Pool2_ips_from_10_92_0_0__10 {
    ClaimResource(poolId:17179869190, userInput: {}) {
        ID
        Properties
    }
}

query QueryPoolHierarchy_3LevelsDeep {
    QueryResources(poolId: 17179869184) {
        # Resources from root pool
        ID
        Properties

        # Level 2 pools
        NestedPool {
            ID
            Name
            PoolType
            Resources {
                ID
                Properties

                # Level 3 pools
                NestedPool {
                    ID
                    Name
                    PoolType
                    Resources {
                        ID
                        Properties
                    }
                }

            }
        }

    }
}

query QueryOnlyIpv4PrefixPools {
    QueryResourcePools(resourceTypeId: 21474836480) {
        ID
        Name
    }
}

query QueryOnlyIpv4AddrPools {
    QueryResourcePools(resourceTypeId: 21474836481) {
        ID
        Name
    }
}

query QueryIpv4PrefixRootPools {
    QueryRootResourcePools(resourceTypeId: 21474836480) {
        ID
        Name
    }
}

query QueryIpv4AddressLeafPools {
    QueryLeafResourcePools(resourceTypeId: 21474836481) {
        ID
        Name
    }
}

# TODO pool properties ? where does root pool store its root prefix ?