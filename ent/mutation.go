// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/net-auto/resourceManager/ent/allocationstrategy"
	"github.com/net-auto/resourceManager/ent/property"
	"github.com/net-auto/resourceManager/ent/propertytype"
	"github.com/net-auto/resourceManager/ent/resource"
	"github.com/net-auto/resourceManager/ent/resourcepool"
	"github.com/net-auto/resourceManager/ent/resourcetype"
	"github.com/net-auto/resourceManager/ent/tag"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAllocationStrategy = "AllocationStrategy"
	TypeProperty           = "Property"
	TypePropertyType       = "PropertyType"
	TypeResource           = "Resource"
	TypeResourcePool       = "ResourcePool"
	TypeResourceType       = "ResourceType"
	TypeTag                = "Tag"
)

// AllocationStrategyMutation represents an operation that mutate the AllocationStrategies
// nodes in the graph.
type AllocationStrategyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	lang          *allocationstrategy.Lang
	script        *string
	clearedFields map[string]struct{}
	pools         map[int]struct{}
	removedpools  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*AllocationStrategy, error)
}

var _ ent.Mutation = (*AllocationStrategyMutation)(nil)

// allocationstrategyOption allows to manage the mutation configuration using functional options.
type allocationstrategyOption func(*AllocationStrategyMutation)

// newAllocationStrategyMutation creates new mutation for $n.Name.
func newAllocationStrategyMutation(c config, op Op, opts ...allocationstrategyOption) *AllocationStrategyMutation {
	m := &AllocationStrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeAllocationStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAllocationStrategyID sets the id field of the mutation.
func withAllocationStrategyID(id int) allocationstrategyOption {
	return func(m *AllocationStrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *AllocationStrategy
		)
		m.oldValue = func(ctx context.Context) (*AllocationStrategy, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AllocationStrategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAllocationStrategy sets the old AllocationStrategy of the mutation.
func withAllocationStrategy(node *AllocationStrategy) allocationstrategyOption {
	return func(m *AllocationStrategyMutation) {
		m.oldValue = func(context.Context) (*AllocationStrategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AllocationStrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AllocationStrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AllocationStrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *AllocationStrategyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *AllocationStrategyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the AllocationStrategy.
// If the AllocationStrategy object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AllocationStrategyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *AllocationStrategyMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *AllocationStrategyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *AllocationStrategyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the AllocationStrategy.
// If the AllocationStrategy object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AllocationStrategyMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *AllocationStrategyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[allocationstrategy.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *AllocationStrategyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[allocationstrategy.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *AllocationStrategyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, allocationstrategy.FieldDescription)
}

// SetLang sets the lang field.
func (m *AllocationStrategyMutation) SetLang(a allocationstrategy.Lang) {
	m.lang = &a
}

// Lang returns the lang value in the mutation.
func (m *AllocationStrategyMutation) Lang() (r allocationstrategy.Lang, exists bool) {
	v := m.lang
	if v == nil {
		return
	}
	return *v, true
}

// OldLang returns the old lang value of the AllocationStrategy.
// If the AllocationStrategy object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AllocationStrategyMutation) OldLang(ctx context.Context) (v allocationstrategy.Lang, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLang is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLang requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLang: %w", err)
	}
	return oldValue.Lang, nil
}

// ResetLang reset all changes of the "lang" field.
func (m *AllocationStrategyMutation) ResetLang() {
	m.lang = nil
}

// SetScript sets the script field.
func (m *AllocationStrategyMutation) SetScript(s string) {
	m.script = &s
}

// Script returns the script value in the mutation.
func (m *AllocationStrategyMutation) Script() (r string, exists bool) {
	v := m.script
	if v == nil {
		return
	}
	return *v, true
}

// OldScript returns the old script value of the AllocationStrategy.
// If the AllocationStrategy object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AllocationStrategyMutation) OldScript(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScript is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScript requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScript: %w", err)
	}
	return oldValue.Script, nil
}

// ResetScript reset all changes of the "script" field.
func (m *AllocationStrategyMutation) ResetScript() {
	m.script = nil
}

// AddPoolIDs adds the pools edge to ResourcePool by ids.
func (m *AllocationStrategyMutation) AddPoolIDs(ids ...int) {
	if m.pools == nil {
		m.pools = make(map[int]struct{})
	}
	for i := range ids {
		m.pools[ids[i]] = struct{}{}
	}
}

// RemovePoolIDs removes the pools edge to ResourcePool by ids.
func (m *AllocationStrategyMutation) RemovePoolIDs(ids ...int) {
	if m.removedpools == nil {
		m.removedpools = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpools[ids[i]] = struct{}{}
	}
}

// RemovedPools returns the removed ids of pools.
func (m *AllocationStrategyMutation) RemovedPoolsIDs() (ids []int) {
	for id := range m.removedpools {
		ids = append(ids, id)
	}
	return
}

// PoolsIDs returns the pools ids in the mutation.
func (m *AllocationStrategyMutation) PoolsIDs() (ids []int) {
	for id := range m.pools {
		ids = append(ids, id)
	}
	return
}

// ResetPools reset all changes of the "pools" edge.
func (m *AllocationStrategyMutation) ResetPools() {
	m.pools = nil
	m.removedpools = nil
}

// Op returns the operation name.
func (m *AllocationStrategyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AllocationStrategy).
func (m *AllocationStrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AllocationStrategyMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, allocationstrategy.FieldName)
	}
	if m.description != nil {
		fields = append(fields, allocationstrategy.FieldDescription)
	}
	if m.lang != nil {
		fields = append(fields, allocationstrategy.FieldLang)
	}
	if m.script != nil {
		fields = append(fields, allocationstrategy.FieldScript)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AllocationStrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case allocationstrategy.FieldName:
		return m.Name()
	case allocationstrategy.FieldDescription:
		return m.Description()
	case allocationstrategy.FieldLang:
		return m.Lang()
	case allocationstrategy.FieldScript:
		return m.Script()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AllocationStrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case allocationstrategy.FieldName:
		return m.OldName(ctx)
	case allocationstrategy.FieldDescription:
		return m.OldDescription(ctx)
	case allocationstrategy.FieldLang:
		return m.OldLang(ctx)
	case allocationstrategy.FieldScript:
		return m.OldScript(ctx)
	}
	return nil, fmt.Errorf("unknown AllocationStrategy field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AllocationStrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case allocationstrategy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case allocationstrategy.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case allocationstrategy.FieldLang:
		v, ok := value.(allocationstrategy.Lang)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLang(v)
		return nil
	case allocationstrategy.FieldScript:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScript(v)
		return nil
	}
	return fmt.Errorf("unknown AllocationStrategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AllocationStrategyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AllocationStrategyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AllocationStrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AllocationStrategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AllocationStrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(allocationstrategy.FieldDescription) {
		fields = append(fields, allocationstrategy.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AllocationStrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AllocationStrategyMutation) ClearField(name string) error {
	switch name {
	case allocationstrategy.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AllocationStrategy nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AllocationStrategyMutation) ResetField(name string) error {
	switch name {
	case allocationstrategy.FieldName:
		m.ResetName()
		return nil
	case allocationstrategy.FieldDescription:
		m.ResetDescription()
		return nil
	case allocationstrategy.FieldLang:
		m.ResetLang()
		return nil
	case allocationstrategy.FieldScript:
		m.ResetScript()
		return nil
	}
	return fmt.Errorf("unknown AllocationStrategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AllocationStrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.pools != nil {
		edges = append(edges, allocationstrategy.EdgePools)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AllocationStrategyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case allocationstrategy.EdgePools:
		ids := make([]ent.Value, 0, len(m.pools))
		for id := range m.pools {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AllocationStrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpools != nil {
		edges = append(edges, allocationstrategy.EdgePools)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AllocationStrategyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case allocationstrategy.EdgePools:
		ids := make([]ent.Value, 0, len(m.removedpools))
		for id := range m.removedpools {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AllocationStrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AllocationStrategyMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AllocationStrategyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AllocationStrategy unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AllocationStrategyMutation) ResetEdge(name string) error {
	switch name {
	case allocationstrategy.EdgePools:
		m.ResetPools()
		return nil
	}
	return fmt.Errorf("unknown AllocationStrategy edge %s", name)
}

// PropertyMutation represents an operation that mutate the Properties
// nodes in the graph.
type PropertyMutation struct {
	config
	op                Op
	typ               string
	id                *int
	int_val           *int
	addint_val        *int
	bool_val          *bool
	float_val         *float64
	addfloat_val      *float64
	latitude_val      *float64
	addlatitude_val   *float64
	longitude_val     *float64
	addlongitude_val  *float64
	range_from_val    *float64
	addrange_from_val *float64
	range_to_val      *float64
	addrange_to_val   *float64
	string_val        *string
	clearedFields     map[string]struct{}
	_type             *int
	cleared_type      bool
	done              bool
	oldValue          func(context.Context) (*Property, error)
}

var _ ent.Mutation = (*PropertyMutation)(nil)

// propertyOption allows to manage the mutation configuration using functional options.
type propertyOption func(*PropertyMutation)

// newPropertyMutation creates new mutation for $n.Name.
func newPropertyMutation(c config, op Op, opts ...propertyOption) *PropertyMutation {
	m := &PropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyID sets the id field of the mutation.
func withPropertyID(id int) propertyOption {
	return func(m *PropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *Property
		)
		m.oldValue = func(ctx context.Context) (*Property, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Property.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProperty sets the old Property of the mutation.
func withProperty(node *Property) propertyOption {
	return func(m *PropertyMutation) {
		m.oldValue = func(context.Context) (*Property, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PropertyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetIntVal sets the int_val field.
func (m *PropertyMutation) SetIntVal(i int) {
	m.int_val = &i
	m.addint_val = nil
}

// IntVal returns the int_val value in the mutation.
func (m *PropertyMutation) IntVal() (r int, exists bool) {
	v := m.int_val
	if v == nil {
		return
	}
	return *v, true
}

// OldIntVal returns the old int_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldIntVal(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIntVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIntVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntVal: %w", err)
	}
	return oldValue.IntVal, nil
}

// AddIntVal adds i to int_val.
func (m *PropertyMutation) AddIntVal(i int) {
	if m.addint_val != nil {
		*m.addint_val += i
	} else {
		m.addint_val = &i
	}
}

// AddedIntVal returns the value that was added to the int_val field in this mutation.
func (m *PropertyMutation) AddedIntVal() (r int, exists bool) {
	v := m.addint_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearIntVal clears the value of int_val.
func (m *PropertyMutation) ClearIntVal() {
	m.int_val = nil
	m.addint_val = nil
	m.clearedFields[property.FieldIntVal] = struct{}{}
}

// IntValCleared returns if the field int_val was cleared in this mutation.
func (m *PropertyMutation) IntValCleared() bool {
	_, ok := m.clearedFields[property.FieldIntVal]
	return ok
}

// ResetIntVal reset all changes of the "int_val" field.
func (m *PropertyMutation) ResetIntVal() {
	m.int_val = nil
	m.addint_val = nil
	delete(m.clearedFields, property.FieldIntVal)
}

// SetBoolVal sets the bool_val field.
func (m *PropertyMutation) SetBoolVal(b bool) {
	m.bool_val = &b
}

// BoolVal returns the bool_val value in the mutation.
func (m *PropertyMutation) BoolVal() (r bool, exists bool) {
	v := m.bool_val
	if v == nil {
		return
	}
	return *v, true
}

// OldBoolVal returns the old bool_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldBoolVal(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBoolVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBoolVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoolVal: %w", err)
	}
	return oldValue.BoolVal, nil
}

// ClearBoolVal clears the value of bool_val.
func (m *PropertyMutation) ClearBoolVal() {
	m.bool_val = nil
	m.clearedFields[property.FieldBoolVal] = struct{}{}
}

// BoolValCleared returns if the field bool_val was cleared in this mutation.
func (m *PropertyMutation) BoolValCleared() bool {
	_, ok := m.clearedFields[property.FieldBoolVal]
	return ok
}

// ResetBoolVal reset all changes of the "bool_val" field.
func (m *PropertyMutation) ResetBoolVal() {
	m.bool_val = nil
	delete(m.clearedFields, property.FieldBoolVal)
}

// SetFloatVal sets the float_val field.
func (m *PropertyMutation) SetFloatVal(f float64) {
	m.float_val = &f
	m.addfloat_val = nil
}

// FloatVal returns the float_val value in the mutation.
func (m *PropertyMutation) FloatVal() (r float64, exists bool) {
	v := m.float_val
	if v == nil {
		return
	}
	return *v, true
}

// OldFloatVal returns the old float_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldFloatVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFloatVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFloatVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloatVal: %w", err)
	}
	return oldValue.FloatVal, nil
}

// AddFloatVal adds f to float_val.
func (m *PropertyMutation) AddFloatVal(f float64) {
	if m.addfloat_val != nil {
		*m.addfloat_val += f
	} else {
		m.addfloat_val = &f
	}
}

// AddedFloatVal returns the value that was added to the float_val field in this mutation.
func (m *PropertyMutation) AddedFloatVal() (r float64, exists bool) {
	v := m.addfloat_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearFloatVal clears the value of float_val.
func (m *PropertyMutation) ClearFloatVal() {
	m.float_val = nil
	m.addfloat_val = nil
	m.clearedFields[property.FieldFloatVal] = struct{}{}
}

// FloatValCleared returns if the field float_val was cleared in this mutation.
func (m *PropertyMutation) FloatValCleared() bool {
	_, ok := m.clearedFields[property.FieldFloatVal]
	return ok
}

// ResetFloatVal reset all changes of the "float_val" field.
func (m *PropertyMutation) ResetFloatVal() {
	m.float_val = nil
	m.addfloat_val = nil
	delete(m.clearedFields, property.FieldFloatVal)
}

// SetLatitudeVal sets the latitude_val field.
func (m *PropertyMutation) SetLatitudeVal(f float64) {
	m.latitude_val = &f
	m.addlatitude_val = nil
}

// LatitudeVal returns the latitude_val value in the mutation.
func (m *PropertyMutation) LatitudeVal() (r float64, exists bool) {
	v := m.latitude_val
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitudeVal returns the old latitude_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldLatitudeVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLatitudeVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLatitudeVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitudeVal: %w", err)
	}
	return oldValue.LatitudeVal, nil
}

// AddLatitudeVal adds f to latitude_val.
func (m *PropertyMutation) AddLatitudeVal(f float64) {
	if m.addlatitude_val != nil {
		*m.addlatitude_val += f
	} else {
		m.addlatitude_val = &f
	}
}

// AddedLatitudeVal returns the value that was added to the latitude_val field in this mutation.
func (m *PropertyMutation) AddedLatitudeVal() (r float64, exists bool) {
	v := m.addlatitude_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitudeVal clears the value of latitude_val.
func (m *PropertyMutation) ClearLatitudeVal() {
	m.latitude_val = nil
	m.addlatitude_val = nil
	m.clearedFields[property.FieldLatitudeVal] = struct{}{}
}

// LatitudeValCleared returns if the field latitude_val was cleared in this mutation.
func (m *PropertyMutation) LatitudeValCleared() bool {
	_, ok := m.clearedFields[property.FieldLatitudeVal]
	return ok
}

// ResetLatitudeVal reset all changes of the "latitude_val" field.
func (m *PropertyMutation) ResetLatitudeVal() {
	m.latitude_val = nil
	m.addlatitude_val = nil
	delete(m.clearedFields, property.FieldLatitudeVal)
}

// SetLongitudeVal sets the longitude_val field.
func (m *PropertyMutation) SetLongitudeVal(f float64) {
	m.longitude_val = &f
	m.addlongitude_val = nil
}

// LongitudeVal returns the longitude_val value in the mutation.
func (m *PropertyMutation) LongitudeVal() (r float64, exists bool) {
	v := m.longitude_val
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitudeVal returns the old longitude_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldLongitudeVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLongitudeVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLongitudeVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitudeVal: %w", err)
	}
	return oldValue.LongitudeVal, nil
}

// AddLongitudeVal adds f to longitude_val.
func (m *PropertyMutation) AddLongitudeVal(f float64) {
	if m.addlongitude_val != nil {
		*m.addlongitude_val += f
	} else {
		m.addlongitude_val = &f
	}
}

// AddedLongitudeVal returns the value that was added to the longitude_val field in this mutation.
func (m *PropertyMutation) AddedLongitudeVal() (r float64, exists bool) {
	v := m.addlongitude_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitudeVal clears the value of longitude_val.
func (m *PropertyMutation) ClearLongitudeVal() {
	m.longitude_val = nil
	m.addlongitude_val = nil
	m.clearedFields[property.FieldLongitudeVal] = struct{}{}
}

// LongitudeValCleared returns if the field longitude_val was cleared in this mutation.
func (m *PropertyMutation) LongitudeValCleared() bool {
	_, ok := m.clearedFields[property.FieldLongitudeVal]
	return ok
}

// ResetLongitudeVal reset all changes of the "longitude_val" field.
func (m *PropertyMutation) ResetLongitudeVal() {
	m.longitude_val = nil
	m.addlongitude_val = nil
	delete(m.clearedFields, property.FieldLongitudeVal)
}

// SetRangeFromVal sets the range_from_val field.
func (m *PropertyMutation) SetRangeFromVal(f float64) {
	m.range_from_val = &f
	m.addrange_from_val = nil
}

// RangeFromVal returns the range_from_val value in the mutation.
func (m *PropertyMutation) RangeFromVal() (r float64, exists bool) {
	v := m.range_from_val
	if v == nil {
		return
	}
	return *v, true
}

// OldRangeFromVal returns the old range_from_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldRangeFromVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRangeFromVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRangeFromVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRangeFromVal: %w", err)
	}
	return oldValue.RangeFromVal, nil
}

// AddRangeFromVal adds f to range_from_val.
func (m *PropertyMutation) AddRangeFromVal(f float64) {
	if m.addrange_from_val != nil {
		*m.addrange_from_val += f
	} else {
		m.addrange_from_val = &f
	}
}

// AddedRangeFromVal returns the value that was added to the range_from_val field in this mutation.
func (m *PropertyMutation) AddedRangeFromVal() (r float64, exists bool) {
	v := m.addrange_from_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearRangeFromVal clears the value of range_from_val.
func (m *PropertyMutation) ClearRangeFromVal() {
	m.range_from_val = nil
	m.addrange_from_val = nil
	m.clearedFields[property.FieldRangeFromVal] = struct{}{}
}

// RangeFromValCleared returns if the field range_from_val was cleared in this mutation.
func (m *PropertyMutation) RangeFromValCleared() bool {
	_, ok := m.clearedFields[property.FieldRangeFromVal]
	return ok
}

// ResetRangeFromVal reset all changes of the "range_from_val" field.
func (m *PropertyMutation) ResetRangeFromVal() {
	m.range_from_val = nil
	m.addrange_from_val = nil
	delete(m.clearedFields, property.FieldRangeFromVal)
}

// SetRangeToVal sets the range_to_val field.
func (m *PropertyMutation) SetRangeToVal(f float64) {
	m.range_to_val = &f
	m.addrange_to_val = nil
}

// RangeToVal returns the range_to_val value in the mutation.
func (m *PropertyMutation) RangeToVal() (r float64, exists bool) {
	v := m.range_to_val
	if v == nil {
		return
	}
	return *v, true
}

// OldRangeToVal returns the old range_to_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldRangeToVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRangeToVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRangeToVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRangeToVal: %w", err)
	}
	return oldValue.RangeToVal, nil
}

// AddRangeToVal adds f to range_to_val.
func (m *PropertyMutation) AddRangeToVal(f float64) {
	if m.addrange_to_val != nil {
		*m.addrange_to_val += f
	} else {
		m.addrange_to_val = &f
	}
}

// AddedRangeToVal returns the value that was added to the range_to_val field in this mutation.
func (m *PropertyMutation) AddedRangeToVal() (r float64, exists bool) {
	v := m.addrange_to_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearRangeToVal clears the value of range_to_val.
func (m *PropertyMutation) ClearRangeToVal() {
	m.range_to_val = nil
	m.addrange_to_val = nil
	m.clearedFields[property.FieldRangeToVal] = struct{}{}
}

// RangeToValCleared returns if the field range_to_val was cleared in this mutation.
func (m *PropertyMutation) RangeToValCleared() bool {
	_, ok := m.clearedFields[property.FieldRangeToVal]
	return ok
}

// ResetRangeToVal reset all changes of the "range_to_val" field.
func (m *PropertyMutation) ResetRangeToVal() {
	m.range_to_val = nil
	m.addrange_to_val = nil
	delete(m.clearedFields, property.FieldRangeToVal)
}

// SetStringVal sets the string_val field.
func (m *PropertyMutation) SetStringVal(s string) {
	m.string_val = &s
}

// StringVal returns the string_val value in the mutation.
func (m *PropertyMutation) StringVal() (r string, exists bool) {
	v := m.string_val
	if v == nil {
		return
	}
	return *v, true
}

// OldStringVal returns the old string_val value of the Property.
// If the Property object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyMutation) OldStringVal(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringVal: %w", err)
	}
	return oldValue.StringVal, nil
}

// ClearStringVal clears the value of string_val.
func (m *PropertyMutation) ClearStringVal() {
	m.string_val = nil
	m.clearedFields[property.FieldStringVal] = struct{}{}
}

// StringValCleared returns if the field string_val was cleared in this mutation.
func (m *PropertyMutation) StringValCleared() bool {
	_, ok := m.clearedFields[property.FieldStringVal]
	return ok
}

// ResetStringVal reset all changes of the "string_val" field.
func (m *PropertyMutation) ResetStringVal() {
	m.string_val = nil
	delete(m.clearedFields, property.FieldStringVal)
}

// SetTypeID sets the type edge to PropertyType by id.
func (m *PropertyMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the type edge to PropertyType.
func (m *PropertyMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the edge type was cleared.
func (m *PropertyMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the type id in the mutation.
func (m *PropertyMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType reset all changes of the "type" edge.
func (m *PropertyMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// Op returns the operation name.
func (m *PropertyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Property).
func (m *PropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PropertyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.int_val != nil {
		fields = append(fields, property.FieldIntVal)
	}
	if m.bool_val != nil {
		fields = append(fields, property.FieldBoolVal)
	}
	if m.float_val != nil {
		fields = append(fields, property.FieldFloatVal)
	}
	if m.latitude_val != nil {
		fields = append(fields, property.FieldLatitudeVal)
	}
	if m.longitude_val != nil {
		fields = append(fields, property.FieldLongitudeVal)
	}
	if m.range_from_val != nil {
		fields = append(fields, property.FieldRangeFromVal)
	}
	if m.range_to_val != nil {
		fields = append(fields, property.FieldRangeToVal)
	}
	if m.string_val != nil {
		fields = append(fields, property.FieldStringVal)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case property.FieldIntVal:
		return m.IntVal()
	case property.FieldBoolVal:
		return m.BoolVal()
	case property.FieldFloatVal:
		return m.FloatVal()
	case property.FieldLatitudeVal:
		return m.LatitudeVal()
	case property.FieldLongitudeVal:
		return m.LongitudeVal()
	case property.FieldRangeFromVal:
		return m.RangeFromVal()
	case property.FieldRangeToVal:
		return m.RangeToVal()
	case property.FieldStringVal:
		return m.StringVal()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case property.FieldIntVal:
		return m.OldIntVal(ctx)
	case property.FieldBoolVal:
		return m.OldBoolVal(ctx)
	case property.FieldFloatVal:
		return m.OldFloatVal(ctx)
	case property.FieldLatitudeVal:
		return m.OldLatitudeVal(ctx)
	case property.FieldLongitudeVal:
		return m.OldLongitudeVal(ctx)
	case property.FieldRangeFromVal:
		return m.OldRangeFromVal(ctx)
	case property.FieldRangeToVal:
		return m.OldRangeToVal(ctx)
	case property.FieldStringVal:
		return m.OldStringVal(ctx)
	}
	return nil, fmt.Errorf("unknown Property field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case property.FieldIntVal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntVal(v)
		return nil
	case property.FieldBoolVal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoolVal(v)
		return nil
	case property.FieldFloatVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloatVal(v)
		return nil
	case property.FieldLatitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitudeVal(v)
		return nil
	case property.FieldLongitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitudeVal(v)
		return nil
	case property.FieldRangeFromVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRangeFromVal(v)
		return nil
	case property.FieldRangeToVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRangeToVal(v)
		return nil
	case property.FieldStringVal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringVal(v)
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PropertyMutation) AddedFields() []string {
	var fields []string
	if m.addint_val != nil {
		fields = append(fields, property.FieldIntVal)
	}
	if m.addfloat_val != nil {
		fields = append(fields, property.FieldFloatVal)
	}
	if m.addlatitude_val != nil {
		fields = append(fields, property.FieldLatitudeVal)
	}
	if m.addlongitude_val != nil {
		fields = append(fields, property.FieldLongitudeVal)
	}
	if m.addrange_from_val != nil {
		fields = append(fields, property.FieldRangeFromVal)
	}
	if m.addrange_to_val != nil {
		fields = append(fields, property.FieldRangeToVal)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PropertyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case property.FieldIntVal:
		return m.AddedIntVal()
	case property.FieldFloatVal:
		return m.AddedFloatVal()
	case property.FieldLatitudeVal:
		return m.AddedLatitudeVal()
	case property.FieldLongitudeVal:
		return m.AddedLongitudeVal()
	case property.FieldRangeFromVal:
		return m.AddedRangeFromVal()
	case property.FieldRangeToVal:
		return m.AddedRangeToVal()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case property.FieldIntVal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntVal(v)
		return nil
	case property.FieldFloatVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloatVal(v)
		return nil
	case property.FieldLatitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitudeVal(v)
		return nil
	case property.FieldLongitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitudeVal(v)
		return nil
	case property.FieldRangeFromVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRangeFromVal(v)
		return nil
	case property.FieldRangeToVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRangeToVal(v)
		return nil
	}
	return fmt.Errorf("unknown Property numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(property.FieldIntVal) {
		fields = append(fields, property.FieldIntVal)
	}
	if m.FieldCleared(property.FieldBoolVal) {
		fields = append(fields, property.FieldBoolVal)
	}
	if m.FieldCleared(property.FieldFloatVal) {
		fields = append(fields, property.FieldFloatVal)
	}
	if m.FieldCleared(property.FieldLatitudeVal) {
		fields = append(fields, property.FieldLatitudeVal)
	}
	if m.FieldCleared(property.FieldLongitudeVal) {
		fields = append(fields, property.FieldLongitudeVal)
	}
	if m.FieldCleared(property.FieldRangeFromVal) {
		fields = append(fields, property.FieldRangeFromVal)
	}
	if m.FieldCleared(property.FieldRangeToVal) {
		fields = append(fields, property.FieldRangeToVal)
	}
	if m.FieldCleared(property.FieldStringVal) {
		fields = append(fields, property.FieldStringVal)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyMutation) ClearField(name string) error {
	switch name {
	case property.FieldIntVal:
		m.ClearIntVal()
		return nil
	case property.FieldBoolVal:
		m.ClearBoolVal()
		return nil
	case property.FieldFloatVal:
		m.ClearFloatVal()
		return nil
	case property.FieldLatitudeVal:
		m.ClearLatitudeVal()
		return nil
	case property.FieldLongitudeVal:
		m.ClearLongitudeVal()
		return nil
	case property.FieldRangeFromVal:
		m.ClearRangeFromVal()
		return nil
	case property.FieldRangeToVal:
		m.ClearRangeToVal()
		return nil
	case property.FieldStringVal:
		m.ClearStringVal()
		return nil
	}
	return fmt.Errorf("unknown Property nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PropertyMutation) ResetField(name string) error {
	switch name {
	case property.FieldIntVal:
		m.ResetIntVal()
		return nil
	case property.FieldBoolVal:
		m.ResetBoolVal()
		return nil
	case property.FieldFloatVal:
		m.ResetFloatVal()
		return nil
	case property.FieldLatitudeVal:
		m.ResetLatitudeVal()
		return nil
	case property.FieldLongitudeVal:
		m.ResetLongitudeVal()
		return nil
	case property.FieldRangeFromVal:
		m.ResetRangeFromVal()
		return nil
	case property.FieldRangeToVal:
		m.ResetRangeToVal()
		return nil
	case property.FieldStringVal:
		m.ResetStringVal()
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._type != nil {
		edges = append(edges, property.EdgeType)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PropertyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_type {
		edges = append(edges, property.EdgeType)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case property.EdgeType:
		return m.cleared_type
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PropertyMutation) ClearEdge(name string) error {
	switch name {
	case property.EdgeType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Property unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PropertyMutation) ResetEdge(name string) error {
	switch name {
	case property.EdgeType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Property edge %s", name)
}

// PropertyTypeMutation represents an operation that mutate the PropertyTypes
// nodes in the graph.
type PropertyTypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_type                *propertytype.Type
	name                 *string
	external_id          *string
	index                *int
	addindex             *int
	category             *string
	int_val              *int
	addint_val           *int
	bool_val             *bool
	float_val            *float64
	addfloat_val         *float64
	latitude_val         *float64
	addlatitude_val      *float64
	longitude_val        *float64
	addlongitude_val     *float64
	string_val           *string
	range_from_val       *float64
	addrange_from_val    *float64
	range_to_val         *float64
	addrange_to_val      *float64
	is_instance_property *bool
	editable             *bool
	mandatory            *bool
	deleted              *bool
	nodeType             *string
	clearedFields        map[string]struct{}
	properties           map[int]struct{}
	removedproperties    map[int]struct{}
	resource_type        *int
	clearedresource_type bool
	done                 bool
	oldValue             func(context.Context) (*PropertyType, error)
}

var _ ent.Mutation = (*PropertyTypeMutation)(nil)

// propertytypeOption allows to manage the mutation configuration using functional options.
type propertytypeOption func(*PropertyTypeMutation)

// newPropertyTypeMutation creates new mutation for $n.Name.
func newPropertyTypeMutation(c config, op Op, opts ...propertytypeOption) *PropertyTypeMutation {
	m := &PropertyTypeMutation{
		config:        c,
		op:            op,
		typ:           TypePropertyType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyTypeID sets the id field of the mutation.
func withPropertyTypeID(id int) propertytypeOption {
	return func(m *PropertyTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *PropertyType
		)
		m.oldValue = func(ctx context.Context) (*PropertyType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PropertyType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPropertyType sets the old PropertyType of the mutation.
func withPropertyType(node *PropertyType) propertytypeOption {
	return func(m *PropertyTypeMutation) {
		m.oldValue = func(context.Context) (*PropertyType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PropertyTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the type field.
func (m *PropertyTypeMutation) SetType(pr propertytype.Type) {
	m._type = &pr
}

// GetType returns the type value in the mutation.
func (m *PropertyTypeMutation) GetType() (r propertytype.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldType(ctx context.Context) (v propertytype.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *PropertyTypeMutation) ResetType() {
	m._type = nil
}

// SetName sets the name field.
func (m *PropertyTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PropertyTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PropertyTypeMutation) ResetName() {
	m.name = nil
}

// SetExternalID sets the external_id field.
func (m *PropertyTypeMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the external_id value in the mutation.
func (m *PropertyTypeMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old external_id value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExternalID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of external_id.
func (m *PropertyTypeMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[propertytype.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the field external_id was cleared in this mutation.
func (m *PropertyTypeMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldExternalID]
	return ok
}

// ResetExternalID reset all changes of the "external_id" field.
func (m *PropertyTypeMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, propertytype.FieldExternalID)
}

// SetIndex sets the index field.
func (m *PropertyTypeMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the index value in the mutation.
func (m *PropertyTypeMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old index value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to index.
func (m *PropertyTypeMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the index field in this mutation.
func (m *PropertyTypeMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndex clears the value of index.
func (m *PropertyTypeMutation) ClearIndex() {
	m.index = nil
	m.addindex = nil
	m.clearedFields[propertytype.FieldIndex] = struct{}{}
}

// IndexCleared returns if the field index was cleared in this mutation.
func (m *PropertyTypeMutation) IndexCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldIndex]
	return ok
}

// ResetIndex reset all changes of the "index" field.
func (m *PropertyTypeMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
	delete(m.clearedFields, propertytype.FieldIndex)
}

// SetCategory sets the category field.
func (m *PropertyTypeMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the category value in the mutation.
func (m *PropertyTypeMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old category value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of category.
func (m *PropertyTypeMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[propertytype.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the field category was cleared in this mutation.
func (m *PropertyTypeMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldCategory]
	return ok
}

// ResetCategory reset all changes of the "category" field.
func (m *PropertyTypeMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, propertytype.FieldCategory)
}

// SetIntVal sets the int_val field.
func (m *PropertyTypeMutation) SetIntVal(i int) {
	m.int_val = &i
	m.addint_val = nil
}

// IntVal returns the int_val value in the mutation.
func (m *PropertyTypeMutation) IntVal() (r int, exists bool) {
	v := m.int_val
	if v == nil {
		return
	}
	return *v, true
}

// OldIntVal returns the old int_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldIntVal(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIntVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIntVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntVal: %w", err)
	}
	return oldValue.IntVal, nil
}

// AddIntVal adds i to int_val.
func (m *PropertyTypeMutation) AddIntVal(i int) {
	if m.addint_val != nil {
		*m.addint_val += i
	} else {
		m.addint_val = &i
	}
}

// AddedIntVal returns the value that was added to the int_val field in this mutation.
func (m *PropertyTypeMutation) AddedIntVal() (r int, exists bool) {
	v := m.addint_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearIntVal clears the value of int_val.
func (m *PropertyTypeMutation) ClearIntVal() {
	m.int_val = nil
	m.addint_val = nil
	m.clearedFields[propertytype.FieldIntVal] = struct{}{}
}

// IntValCleared returns if the field int_val was cleared in this mutation.
func (m *PropertyTypeMutation) IntValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldIntVal]
	return ok
}

// ResetIntVal reset all changes of the "int_val" field.
func (m *PropertyTypeMutation) ResetIntVal() {
	m.int_val = nil
	m.addint_val = nil
	delete(m.clearedFields, propertytype.FieldIntVal)
}

// SetBoolVal sets the bool_val field.
func (m *PropertyTypeMutation) SetBoolVal(b bool) {
	m.bool_val = &b
}

// BoolVal returns the bool_val value in the mutation.
func (m *PropertyTypeMutation) BoolVal() (r bool, exists bool) {
	v := m.bool_val
	if v == nil {
		return
	}
	return *v, true
}

// OldBoolVal returns the old bool_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldBoolVal(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBoolVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBoolVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoolVal: %w", err)
	}
	return oldValue.BoolVal, nil
}

// ClearBoolVal clears the value of bool_val.
func (m *PropertyTypeMutation) ClearBoolVal() {
	m.bool_val = nil
	m.clearedFields[propertytype.FieldBoolVal] = struct{}{}
}

// BoolValCleared returns if the field bool_val was cleared in this mutation.
func (m *PropertyTypeMutation) BoolValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldBoolVal]
	return ok
}

// ResetBoolVal reset all changes of the "bool_val" field.
func (m *PropertyTypeMutation) ResetBoolVal() {
	m.bool_val = nil
	delete(m.clearedFields, propertytype.FieldBoolVal)
}

// SetFloatVal sets the float_val field.
func (m *PropertyTypeMutation) SetFloatVal(f float64) {
	m.float_val = &f
	m.addfloat_val = nil
}

// FloatVal returns the float_val value in the mutation.
func (m *PropertyTypeMutation) FloatVal() (r float64, exists bool) {
	v := m.float_val
	if v == nil {
		return
	}
	return *v, true
}

// OldFloatVal returns the old float_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldFloatVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFloatVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFloatVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloatVal: %w", err)
	}
	return oldValue.FloatVal, nil
}

// AddFloatVal adds f to float_val.
func (m *PropertyTypeMutation) AddFloatVal(f float64) {
	if m.addfloat_val != nil {
		*m.addfloat_val += f
	} else {
		m.addfloat_val = &f
	}
}

// AddedFloatVal returns the value that was added to the float_val field in this mutation.
func (m *PropertyTypeMutation) AddedFloatVal() (r float64, exists bool) {
	v := m.addfloat_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearFloatVal clears the value of float_val.
func (m *PropertyTypeMutation) ClearFloatVal() {
	m.float_val = nil
	m.addfloat_val = nil
	m.clearedFields[propertytype.FieldFloatVal] = struct{}{}
}

// FloatValCleared returns if the field float_val was cleared in this mutation.
func (m *PropertyTypeMutation) FloatValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldFloatVal]
	return ok
}

// ResetFloatVal reset all changes of the "float_val" field.
func (m *PropertyTypeMutation) ResetFloatVal() {
	m.float_val = nil
	m.addfloat_val = nil
	delete(m.clearedFields, propertytype.FieldFloatVal)
}

// SetLatitudeVal sets the latitude_val field.
func (m *PropertyTypeMutation) SetLatitudeVal(f float64) {
	m.latitude_val = &f
	m.addlatitude_val = nil
}

// LatitudeVal returns the latitude_val value in the mutation.
func (m *PropertyTypeMutation) LatitudeVal() (r float64, exists bool) {
	v := m.latitude_val
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitudeVal returns the old latitude_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldLatitudeVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLatitudeVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLatitudeVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitudeVal: %w", err)
	}
	return oldValue.LatitudeVal, nil
}

// AddLatitudeVal adds f to latitude_val.
func (m *PropertyTypeMutation) AddLatitudeVal(f float64) {
	if m.addlatitude_val != nil {
		*m.addlatitude_val += f
	} else {
		m.addlatitude_val = &f
	}
}

// AddedLatitudeVal returns the value that was added to the latitude_val field in this mutation.
func (m *PropertyTypeMutation) AddedLatitudeVal() (r float64, exists bool) {
	v := m.addlatitude_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitudeVal clears the value of latitude_val.
func (m *PropertyTypeMutation) ClearLatitudeVal() {
	m.latitude_val = nil
	m.addlatitude_val = nil
	m.clearedFields[propertytype.FieldLatitudeVal] = struct{}{}
}

// LatitudeValCleared returns if the field latitude_val was cleared in this mutation.
func (m *PropertyTypeMutation) LatitudeValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldLatitudeVal]
	return ok
}

// ResetLatitudeVal reset all changes of the "latitude_val" field.
func (m *PropertyTypeMutation) ResetLatitudeVal() {
	m.latitude_val = nil
	m.addlatitude_val = nil
	delete(m.clearedFields, propertytype.FieldLatitudeVal)
}

// SetLongitudeVal sets the longitude_val field.
func (m *PropertyTypeMutation) SetLongitudeVal(f float64) {
	m.longitude_val = &f
	m.addlongitude_val = nil
}

// LongitudeVal returns the longitude_val value in the mutation.
func (m *PropertyTypeMutation) LongitudeVal() (r float64, exists bool) {
	v := m.longitude_val
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitudeVal returns the old longitude_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldLongitudeVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLongitudeVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLongitudeVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitudeVal: %w", err)
	}
	return oldValue.LongitudeVal, nil
}

// AddLongitudeVal adds f to longitude_val.
func (m *PropertyTypeMutation) AddLongitudeVal(f float64) {
	if m.addlongitude_val != nil {
		*m.addlongitude_val += f
	} else {
		m.addlongitude_val = &f
	}
}

// AddedLongitudeVal returns the value that was added to the longitude_val field in this mutation.
func (m *PropertyTypeMutation) AddedLongitudeVal() (r float64, exists bool) {
	v := m.addlongitude_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitudeVal clears the value of longitude_val.
func (m *PropertyTypeMutation) ClearLongitudeVal() {
	m.longitude_val = nil
	m.addlongitude_val = nil
	m.clearedFields[propertytype.FieldLongitudeVal] = struct{}{}
}

// LongitudeValCleared returns if the field longitude_val was cleared in this mutation.
func (m *PropertyTypeMutation) LongitudeValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldLongitudeVal]
	return ok
}

// ResetLongitudeVal reset all changes of the "longitude_val" field.
func (m *PropertyTypeMutation) ResetLongitudeVal() {
	m.longitude_val = nil
	m.addlongitude_val = nil
	delete(m.clearedFields, propertytype.FieldLongitudeVal)
}

// SetStringVal sets the string_val field.
func (m *PropertyTypeMutation) SetStringVal(s string) {
	m.string_val = &s
}

// StringVal returns the string_val value in the mutation.
func (m *PropertyTypeMutation) StringVal() (r string, exists bool) {
	v := m.string_val
	if v == nil {
		return
	}
	return *v, true
}

// OldStringVal returns the old string_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldStringVal(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStringVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStringVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStringVal: %w", err)
	}
	return oldValue.StringVal, nil
}

// ClearStringVal clears the value of string_val.
func (m *PropertyTypeMutation) ClearStringVal() {
	m.string_val = nil
	m.clearedFields[propertytype.FieldStringVal] = struct{}{}
}

// StringValCleared returns if the field string_val was cleared in this mutation.
func (m *PropertyTypeMutation) StringValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldStringVal]
	return ok
}

// ResetStringVal reset all changes of the "string_val" field.
func (m *PropertyTypeMutation) ResetStringVal() {
	m.string_val = nil
	delete(m.clearedFields, propertytype.FieldStringVal)
}

// SetRangeFromVal sets the range_from_val field.
func (m *PropertyTypeMutation) SetRangeFromVal(f float64) {
	m.range_from_val = &f
	m.addrange_from_val = nil
}

// RangeFromVal returns the range_from_val value in the mutation.
func (m *PropertyTypeMutation) RangeFromVal() (r float64, exists bool) {
	v := m.range_from_val
	if v == nil {
		return
	}
	return *v, true
}

// OldRangeFromVal returns the old range_from_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldRangeFromVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRangeFromVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRangeFromVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRangeFromVal: %w", err)
	}
	return oldValue.RangeFromVal, nil
}

// AddRangeFromVal adds f to range_from_val.
func (m *PropertyTypeMutation) AddRangeFromVal(f float64) {
	if m.addrange_from_val != nil {
		*m.addrange_from_val += f
	} else {
		m.addrange_from_val = &f
	}
}

// AddedRangeFromVal returns the value that was added to the range_from_val field in this mutation.
func (m *PropertyTypeMutation) AddedRangeFromVal() (r float64, exists bool) {
	v := m.addrange_from_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearRangeFromVal clears the value of range_from_val.
func (m *PropertyTypeMutation) ClearRangeFromVal() {
	m.range_from_val = nil
	m.addrange_from_val = nil
	m.clearedFields[propertytype.FieldRangeFromVal] = struct{}{}
}

// RangeFromValCleared returns if the field range_from_val was cleared in this mutation.
func (m *PropertyTypeMutation) RangeFromValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldRangeFromVal]
	return ok
}

// ResetRangeFromVal reset all changes of the "range_from_val" field.
func (m *PropertyTypeMutation) ResetRangeFromVal() {
	m.range_from_val = nil
	m.addrange_from_val = nil
	delete(m.clearedFields, propertytype.FieldRangeFromVal)
}

// SetRangeToVal sets the range_to_val field.
func (m *PropertyTypeMutation) SetRangeToVal(f float64) {
	m.range_to_val = &f
	m.addrange_to_val = nil
}

// RangeToVal returns the range_to_val value in the mutation.
func (m *PropertyTypeMutation) RangeToVal() (r float64, exists bool) {
	v := m.range_to_val
	if v == nil {
		return
	}
	return *v, true
}

// OldRangeToVal returns the old range_to_val value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldRangeToVal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRangeToVal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRangeToVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRangeToVal: %w", err)
	}
	return oldValue.RangeToVal, nil
}

// AddRangeToVal adds f to range_to_val.
func (m *PropertyTypeMutation) AddRangeToVal(f float64) {
	if m.addrange_to_val != nil {
		*m.addrange_to_val += f
	} else {
		m.addrange_to_val = &f
	}
}

// AddedRangeToVal returns the value that was added to the range_to_val field in this mutation.
func (m *PropertyTypeMutation) AddedRangeToVal() (r float64, exists bool) {
	v := m.addrange_to_val
	if v == nil {
		return
	}
	return *v, true
}

// ClearRangeToVal clears the value of range_to_val.
func (m *PropertyTypeMutation) ClearRangeToVal() {
	m.range_to_val = nil
	m.addrange_to_val = nil
	m.clearedFields[propertytype.FieldRangeToVal] = struct{}{}
}

// RangeToValCleared returns if the field range_to_val was cleared in this mutation.
func (m *PropertyTypeMutation) RangeToValCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldRangeToVal]
	return ok
}

// ResetRangeToVal reset all changes of the "range_to_val" field.
func (m *PropertyTypeMutation) ResetRangeToVal() {
	m.range_to_val = nil
	m.addrange_to_val = nil
	delete(m.clearedFields, propertytype.FieldRangeToVal)
}

// SetIsInstanceProperty sets the is_instance_property field.
func (m *PropertyTypeMutation) SetIsInstanceProperty(b bool) {
	m.is_instance_property = &b
}

// IsInstanceProperty returns the is_instance_property value in the mutation.
func (m *PropertyTypeMutation) IsInstanceProperty() (r bool, exists bool) {
	v := m.is_instance_property
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInstanceProperty returns the old is_instance_property value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldIsInstanceProperty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsInstanceProperty is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsInstanceProperty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInstanceProperty: %w", err)
	}
	return oldValue.IsInstanceProperty, nil
}

// ResetIsInstanceProperty reset all changes of the "is_instance_property" field.
func (m *PropertyTypeMutation) ResetIsInstanceProperty() {
	m.is_instance_property = nil
}

// SetEditable sets the editable field.
func (m *PropertyTypeMutation) SetEditable(b bool) {
	m.editable = &b
}

// Editable returns the editable value in the mutation.
func (m *PropertyTypeMutation) Editable() (r bool, exists bool) {
	v := m.editable
	if v == nil {
		return
	}
	return *v, true
}

// OldEditable returns the old editable value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldEditable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEditable is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEditable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEditable: %w", err)
	}
	return oldValue.Editable, nil
}

// ResetEditable reset all changes of the "editable" field.
func (m *PropertyTypeMutation) ResetEditable() {
	m.editable = nil
}

// SetMandatory sets the mandatory field.
func (m *PropertyTypeMutation) SetMandatory(b bool) {
	m.mandatory = &b
}

// Mandatory returns the mandatory value in the mutation.
func (m *PropertyTypeMutation) Mandatory() (r bool, exists bool) {
	v := m.mandatory
	if v == nil {
		return
	}
	return *v, true
}

// OldMandatory returns the old mandatory value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldMandatory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMandatory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMandatory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMandatory: %w", err)
	}
	return oldValue.Mandatory, nil
}

// ResetMandatory reset all changes of the "mandatory" field.
func (m *PropertyTypeMutation) ResetMandatory() {
	m.mandatory = nil
}

// SetDeleted sets the deleted field.
func (m *PropertyTypeMutation) SetDeleted(b bool) {
	m.deleted = &b
}

// Deleted returns the deleted value in the mutation.
func (m *PropertyTypeMutation) Deleted() (r bool, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *PropertyTypeMutation) ResetDeleted() {
	m.deleted = nil
}

// SetNodeType sets the nodeType field.
func (m *PropertyTypeMutation) SetNodeType(s string) {
	m.nodeType = &s
}

// NodeType returns the nodeType value in the mutation.
func (m *PropertyTypeMutation) NodeType() (r string, exists bool) {
	v := m.nodeType
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeType returns the old nodeType value of the PropertyType.
// If the PropertyType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PropertyTypeMutation) OldNodeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNodeType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNodeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeType: %w", err)
	}
	return oldValue.NodeType, nil
}

// ClearNodeType clears the value of nodeType.
func (m *PropertyTypeMutation) ClearNodeType() {
	m.nodeType = nil
	m.clearedFields[propertytype.FieldNodeType] = struct{}{}
}

// NodeTypeCleared returns if the field nodeType was cleared in this mutation.
func (m *PropertyTypeMutation) NodeTypeCleared() bool {
	_, ok := m.clearedFields[propertytype.FieldNodeType]
	return ok
}

// ResetNodeType reset all changes of the "nodeType" field.
func (m *PropertyTypeMutation) ResetNodeType() {
	m.nodeType = nil
	delete(m.clearedFields, propertytype.FieldNodeType)
}

// AddPropertyIDs adds the properties edge to Property by ids.
func (m *PropertyTypeMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// RemovePropertyIDs removes the properties edge to Property by ids.
func (m *PropertyTypeMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed ids of properties.
func (m *PropertyTypeMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the properties ids in the mutation.
func (m *PropertyTypeMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties reset all changes of the "properties" edge.
func (m *PropertyTypeMutation) ResetProperties() {
	m.properties = nil
	m.removedproperties = nil
}

// SetResourceTypeID sets the resource_type edge to ResourceType by id.
func (m *PropertyTypeMutation) SetResourceTypeID(id int) {
	m.resource_type = &id
}

// ClearResourceType clears the resource_type edge to ResourceType.
func (m *PropertyTypeMutation) ClearResourceType() {
	m.clearedresource_type = true
}

// ResourceTypeCleared returns if the edge resource_type was cleared.
func (m *PropertyTypeMutation) ResourceTypeCleared() bool {
	return m.clearedresource_type
}

// ResourceTypeID returns the resource_type id in the mutation.
func (m *PropertyTypeMutation) ResourceTypeID() (id int, exists bool) {
	if m.resource_type != nil {
		return *m.resource_type, true
	}
	return
}

// ResourceTypeIDs returns the resource_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ResourceTypeID instead. It exists only for internal usage by the builders.
func (m *PropertyTypeMutation) ResourceTypeIDs() (ids []int) {
	if id := m.resource_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResourceType reset all changes of the "resource_type" edge.
func (m *PropertyTypeMutation) ResetResourceType() {
	m.resource_type = nil
	m.clearedresource_type = false
}

// Op returns the operation name.
func (m *PropertyTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PropertyType).
func (m *PropertyTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PropertyTypeMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m._type != nil {
		fields = append(fields, propertytype.FieldType)
	}
	if m.name != nil {
		fields = append(fields, propertytype.FieldName)
	}
	if m.external_id != nil {
		fields = append(fields, propertytype.FieldExternalID)
	}
	if m.index != nil {
		fields = append(fields, propertytype.FieldIndex)
	}
	if m.category != nil {
		fields = append(fields, propertytype.FieldCategory)
	}
	if m.int_val != nil {
		fields = append(fields, propertytype.FieldIntVal)
	}
	if m.bool_val != nil {
		fields = append(fields, propertytype.FieldBoolVal)
	}
	if m.float_val != nil {
		fields = append(fields, propertytype.FieldFloatVal)
	}
	if m.latitude_val != nil {
		fields = append(fields, propertytype.FieldLatitudeVal)
	}
	if m.longitude_val != nil {
		fields = append(fields, propertytype.FieldLongitudeVal)
	}
	if m.string_val != nil {
		fields = append(fields, propertytype.FieldStringVal)
	}
	if m.range_from_val != nil {
		fields = append(fields, propertytype.FieldRangeFromVal)
	}
	if m.range_to_val != nil {
		fields = append(fields, propertytype.FieldRangeToVal)
	}
	if m.is_instance_property != nil {
		fields = append(fields, propertytype.FieldIsInstanceProperty)
	}
	if m.editable != nil {
		fields = append(fields, propertytype.FieldEditable)
	}
	if m.mandatory != nil {
		fields = append(fields, propertytype.FieldMandatory)
	}
	if m.deleted != nil {
		fields = append(fields, propertytype.FieldDeleted)
	}
	if m.nodeType != nil {
		fields = append(fields, propertytype.FieldNodeType)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PropertyTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case propertytype.FieldType:
		return m.GetType()
	case propertytype.FieldName:
		return m.Name()
	case propertytype.FieldExternalID:
		return m.ExternalID()
	case propertytype.FieldIndex:
		return m.Index()
	case propertytype.FieldCategory:
		return m.Category()
	case propertytype.FieldIntVal:
		return m.IntVal()
	case propertytype.FieldBoolVal:
		return m.BoolVal()
	case propertytype.FieldFloatVal:
		return m.FloatVal()
	case propertytype.FieldLatitudeVal:
		return m.LatitudeVal()
	case propertytype.FieldLongitudeVal:
		return m.LongitudeVal()
	case propertytype.FieldStringVal:
		return m.StringVal()
	case propertytype.FieldRangeFromVal:
		return m.RangeFromVal()
	case propertytype.FieldRangeToVal:
		return m.RangeToVal()
	case propertytype.FieldIsInstanceProperty:
		return m.IsInstanceProperty()
	case propertytype.FieldEditable:
		return m.Editable()
	case propertytype.FieldMandatory:
		return m.Mandatory()
	case propertytype.FieldDeleted:
		return m.Deleted()
	case propertytype.FieldNodeType:
		return m.NodeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PropertyTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case propertytype.FieldType:
		return m.OldType(ctx)
	case propertytype.FieldName:
		return m.OldName(ctx)
	case propertytype.FieldExternalID:
		return m.OldExternalID(ctx)
	case propertytype.FieldIndex:
		return m.OldIndex(ctx)
	case propertytype.FieldCategory:
		return m.OldCategory(ctx)
	case propertytype.FieldIntVal:
		return m.OldIntVal(ctx)
	case propertytype.FieldBoolVal:
		return m.OldBoolVal(ctx)
	case propertytype.FieldFloatVal:
		return m.OldFloatVal(ctx)
	case propertytype.FieldLatitudeVal:
		return m.OldLatitudeVal(ctx)
	case propertytype.FieldLongitudeVal:
		return m.OldLongitudeVal(ctx)
	case propertytype.FieldStringVal:
		return m.OldStringVal(ctx)
	case propertytype.FieldRangeFromVal:
		return m.OldRangeFromVal(ctx)
	case propertytype.FieldRangeToVal:
		return m.OldRangeToVal(ctx)
	case propertytype.FieldIsInstanceProperty:
		return m.OldIsInstanceProperty(ctx)
	case propertytype.FieldEditable:
		return m.OldEditable(ctx)
	case propertytype.FieldMandatory:
		return m.OldMandatory(ctx)
	case propertytype.FieldDeleted:
		return m.OldDeleted(ctx)
	case propertytype.FieldNodeType:
		return m.OldNodeType(ctx)
	}
	return nil, fmt.Errorf("unknown PropertyType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PropertyTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case propertytype.FieldType:
		v, ok := value.(propertytype.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case propertytype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case propertytype.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case propertytype.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case propertytype.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case propertytype.FieldIntVal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntVal(v)
		return nil
	case propertytype.FieldBoolVal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoolVal(v)
		return nil
	case propertytype.FieldFloatVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloatVal(v)
		return nil
	case propertytype.FieldLatitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitudeVal(v)
		return nil
	case propertytype.FieldLongitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitudeVal(v)
		return nil
	case propertytype.FieldStringVal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStringVal(v)
		return nil
	case propertytype.FieldRangeFromVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRangeFromVal(v)
		return nil
	case propertytype.FieldRangeToVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRangeToVal(v)
		return nil
	case propertytype.FieldIsInstanceProperty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInstanceProperty(v)
		return nil
	case propertytype.FieldEditable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEditable(v)
		return nil
	case propertytype.FieldMandatory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMandatory(v)
		return nil
	case propertytype.FieldDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	case propertytype.FieldNodeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeType(v)
		return nil
	}
	return fmt.Errorf("unknown PropertyType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PropertyTypeMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, propertytype.FieldIndex)
	}
	if m.addint_val != nil {
		fields = append(fields, propertytype.FieldIntVal)
	}
	if m.addfloat_val != nil {
		fields = append(fields, propertytype.FieldFloatVal)
	}
	if m.addlatitude_val != nil {
		fields = append(fields, propertytype.FieldLatitudeVal)
	}
	if m.addlongitude_val != nil {
		fields = append(fields, propertytype.FieldLongitudeVal)
	}
	if m.addrange_from_val != nil {
		fields = append(fields, propertytype.FieldRangeFromVal)
	}
	if m.addrange_to_val != nil {
		fields = append(fields, propertytype.FieldRangeToVal)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PropertyTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case propertytype.FieldIndex:
		return m.AddedIndex()
	case propertytype.FieldIntVal:
		return m.AddedIntVal()
	case propertytype.FieldFloatVal:
		return m.AddedFloatVal()
	case propertytype.FieldLatitudeVal:
		return m.AddedLatitudeVal()
	case propertytype.FieldLongitudeVal:
		return m.AddedLongitudeVal()
	case propertytype.FieldRangeFromVal:
		return m.AddedRangeFromVal()
	case propertytype.FieldRangeToVal:
		return m.AddedRangeToVal()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PropertyTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case propertytype.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	case propertytype.FieldIntVal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIntVal(v)
		return nil
	case propertytype.FieldFloatVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloatVal(v)
		return nil
	case propertytype.FieldLatitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitudeVal(v)
		return nil
	case propertytype.FieldLongitudeVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitudeVal(v)
		return nil
	case propertytype.FieldRangeFromVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRangeFromVal(v)
		return nil
	case propertytype.FieldRangeToVal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRangeToVal(v)
		return nil
	}
	return fmt.Errorf("unknown PropertyType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PropertyTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(propertytype.FieldExternalID) {
		fields = append(fields, propertytype.FieldExternalID)
	}
	if m.FieldCleared(propertytype.FieldIndex) {
		fields = append(fields, propertytype.FieldIndex)
	}
	if m.FieldCleared(propertytype.FieldCategory) {
		fields = append(fields, propertytype.FieldCategory)
	}
	if m.FieldCleared(propertytype.FieldIntVal) {
		fields = append(fields, propertytype.FieldIntVal)
	}
	if m.FieldCleared(propertytype.FieldBoolVal) {
		fields = append(fields, propertytype.FieldBoolVal)
	}
	if m.FieldCleared(propertytype.FieldFloatVal) {
		fields = append(fields, propertytype.FieldFloatVal)
	}
	if m.FieldCleared(propertytype.FieldLatitudeVal) {
		fields = append(fields, propertytype.FieldLatitudeVal)
	}
	if m.FieldCleared(propertytype.FieldLongitudeVal) {
		fields = append(fields, propertytype.FieldLongitudeVal)
	}
	if m.FieldCleared(propertytype.FieldStringVal) {
		fields = append(fields, propertytype.FieldStringVal)
	}
	if m.FieldCleared(propertytype.FieldRangeFromVal) {
		fields = append(fields, propertytype.FieldRangeFromVal)
	}
	if m.FieldCleared(propertytype.FieldRangeToVal) {
		fields = append(fields, propertytype.FieldRangeToVal)
	}
	if m.FieldCleared(propertytype.FieldNodeType) {
		fields = append(fields, propertytype.FieldNodeType)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PropertyTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyTypeMutation) ClearField(name string) error {
	switch name {
	case propertytype.FieldExternalID:
		m.ClearExternalID()
		return nil
	case propertytype.FieldIndex:
		m.ClearIndex()
		return nil
	case propertytype.FieldCategory:
		m.ClearCategory()
		return nil
	case propertytype.FieldIntVal:
		m.ClearIntVal()
		return nil
	case propertytype.FieldBoolVal:
		m.ClearBoolVal()
		return nil
	case propertytype.FieldFloatVal:
		m.ClearFloatVal()
		return nil
	case propertytype.FieldLatitudeVal:
		m.ClearLatitudeVal()
		return nil
	case propertytype.FieldLongitudeVal:
		m.ClearLongitudeVal()
		return nil
	case propertytype.FieldStringVal:
		m.ClearStringVal()
		return nil
	case propertytype.FieldRangeFromVal:
		m.ClearRangeFromVal()
		return nil
	case propertytype.FieldRangeToVal:
		m.ClearRangeToVal()
		return nil
	case propertytype.FieldNodeType:
		m.ClearNodeType()
		return nil
	}
	return fmt.Errorf("unknown PropertyType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PropertyTypeMutation) ResetField(name string) error {
	switch name {
	case propertytype.FieldType:
		m.ResetType()
		return nil
	case propertytype.FieldName:
		m.ResetName()
		return nil
	case propertytype.FieldExternalID:
		m.ResetExternalID()
		return nil
	case propertytype.FieldIndex:
		m.ResetIndex()
		return nil
	case propertytype.FieldCategory:
		m.ResetCategory()
		return nil
	case propertytype.FieldIntVal:
		m.ResetIntVal()
		return nil
	case propertytype.FieldBoolVal:
		m.ResetBoolVal()
		return nil
	case propertytype.FieldFloatVal:
		m.ResetFloatVal()
		return nil
	case propertytype.FieldLatitudeVal:
		m.ResetLatitudeVal()
		return nil
	case propertytype.FieldLongitudeVal:
		m.ResetLongitudeVal()
		return nil
	case propertytype.FieldStringVal:
		m.ResetStringVal()
		return nil
	case propertytype.FieldRangeFromVal:
		m.ResetRangeFromVal()
		return nil
	case propertytype.FieldRangeToVal:
		m.ResetRangeToVal()
		return nil
	case propertytype.FieldIsInstanceProperty:
		m.ResetIsInstanceProperty()
		return nil
	case propertytype.FieldEditable:
		m.ResetEditable()
		return nil
	case propertytype.FieldMandatory:
		m.ResetMandatory()
		return nil
	case propertytype.FieldDeleted:
		m.ResetDeleted()
		return nil
	case propertytype.FieldNodeType:
		m.ResetNodeType()
		return nil
	}
	return fmt.Errorf("unknown PropertyType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PropertyTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.properties != nil {
		edges = append(edges, propertytype.EdgeProperties)
	}
	if m.resource_type != nil {
		edges = append(edges, propertytype.EdgeResourceType)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PropertyTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case propertytype.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case propertytype.EdgeResourceType:
		if id := m.resource_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PropertyTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproperties != nil {
		edges = append(edges, propertytype.EdgeProperties)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PropertyTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case propertytype.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PropertyTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedresource_type {
		edges = append(edges, propertytype.EdgeResourceType)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PropertyTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case propertytype.EdgeResourceType:
		return m.clearedresource_type
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PropertyTypeMutation) ClearEdge(name string) error {
	switch name {
	case propertytype.EdgeResourceType:
		m.ClearResourceType()
		return nil
	}
	return fmt.Errorf("unknown PropertyType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PropertyTypeMutation) ResetEdge(name string) error {
	switch name {
	case propertytype.EdgeProperties:
		m.ResetProperties()
		return nil
	case propertytype.EdgeResourceType:
		m.ResetResourceType()
		return nil
	}
	return fmt.Errorf("unknown PropertyType edge %s", name)
}

// ResourceMutation represents an operation that mutate the Resources
// nodes in the graph.
type ResourceMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	status             *resource.Status
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	pool               *int
	clearedpool        bool
	properties         map[int]struct{}
	removedproperties  map[int]struct{}
	nested_pool        *int
	clearednested_pool bool
	done               bool
	oldValue           func(context.Context) (*Resource, error)
}

var _ ent.Mutation = (*ResourceMutation)(nil)

// resourceOption allows to manage the mutation configuration using functional options.
type resourceOption func(*ResourceMutation)

// newResourceMutation creates new mutation for $n.Name.
func newResourceMutation(c config, op Op, opts ...resourceOption) *ResourceMutation {
	m := &ResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceID sets the id field of the mutation.
func withResourceID(id int) resourceOption {
	return func(m *ResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Resource
		)
		m.oldValue = func(ctx context.Context) (*Resource, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResource sets the old Resource of the mutation.
func withResource(node *Resource) resourceOption {
	return func(m *ResourceMutation) {
		m.oldValue = func(context.Context) (*Resource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ResourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatus sets the status field.
func (m *ResourceMutation) SetStatus(r resource.Status) {
	m.status = &r
}

// Status returns the status value in the mutation.
func (m *ResourceMutation) Status() (r resource.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Resource.
// If the Resource object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceMutation) OldStatus(ctx context.Context) (v resource.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *ResourceMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *ResourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *ResourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Resource.
// If the Resource object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *ResourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPoolID sets the pool edge to ResourcePool by id.
func (m *ResourceMutation) SetPoolID(id int) {
	m.pool = &id
}

// ClearPool clears the pool edge to ResourcePool.
func (m *ResourceMutation) ClearPool() {
	m.clearedpool = true
}

// PoolCleared returns if the edge pool was cleared.
func (m *ResourceMutation) PoolCleared() bool {
	return m.clearedpool
}

// PoolID returns the pool id in the mutation.
func (m *ResourceMutation) PoolID() (id int, exists bool) {
	if m.pool != nil {
		return *m.pool, true
	}
	return
}

// PoolIDs returns the pool ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PoolID instead. It exists only for internal usage by the builders.
func (m *ResourceMutation) PoolIDs() (ids []int) {
	if id := m.pool; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPool reset all changes of the "pool" edge.
func (m *ResourceMutation) ResetPool() {
	m.pool = nil
	m.clearedpool = false
}

// AddPropertyIDs adds the properties edge to Property by ids.
func (m *ResourceMutation) AddPropertyIDs(ids ...int) {
	if m.properties == nil {
		m.properties = make(map[int]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// RemovePropertyIDs removes the properties edge to Property by ids.
func (m *ResourceMutation) RemovePropertyIDs(ids ...int) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed ids of properties.
func (m *ResourceMutation) RemovedPropertiesIDs() (ids []int) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the properties ids in the mutation.
func (m *ResourceMutation) PropertiesIDs() (ids []int) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties reset all changes of the "properties" edge.
func (m *ResourceMutation) ResetProperties() {
	m.properties = nil
	m.removedproperties = nil
}

// SetNestedPoolID sets the nested_pool edge to ResourcePool by id.
func (m *ResourceMutation) SetNestedPoolID(id int) {
	m.nested_pool = &id
}

// ClearNestedPool clears the nested_pool edge to ResourcePool.
func (m *ResourceMutation) ClearNestedPool() {
	m.clearednested_pool = true
}

// NestedPoolCleared returns if the edge nested_pool was cleared.
func (m *ResourceMutation) NestedPoolCleared() bool {
	return m.clearednested_pool
}

// NestedPoolID returns the nested_pool id in the mutation.
func (m *ResourceMutation) NestedPoolID() (id int, exists bool) {
	if m.nested_pool != nil {
		return *m.nested_pool, true
	}
	return
}

// NestedPoolIDs returns the nested_pool ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// NestedPoolID instead. It exists only for internal usage by the builders.
func (m *ResourceMutation) NestedPoolIDs() (ids []int) {
	if id := m.nested_pool; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNestedPool reset all changes of the "nested_pool" edge.
func (m *ResourceMutation) ResetNestedPool() {
	m.nested_pool = nil
	m.clearednested_pool = false
}

// Op returns the operation name.
func (m *ResourceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Resource).
func (m *ResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ResourceMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.status != nil {
		fields = append(fields, resource.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, resource.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldStatus:
		return m.Status()
	case resource.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resource.FieldStatus:
		return m.OldStatus(ctx)
	case resource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Resource field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resource.FieldStatus:
		v, ok := value.(resource.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case resource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ResourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ResourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ResourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Resource nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ResourceMutation) ResetField(name string) error {
	switch name {
	case resource.FieldStatus:
		m.ResetStatus()
		return nil
	case resource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.pool != nil {
		edges = append(edges, resource.EdgePool)
	}
	if m.properties != nil {
		edges = append(edges, resource.EdgeProperties)
	}
	if m.nested_pool != nil {
		edges = append(edges, resource.EdgeNestedPool)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgePool:
		if id := m.pool; id != nil {
			return []ent.Value{*id}
		}
	case resource.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case resource.EdgeNestedPool:
		if id := m.nested_pool; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproperties != nil {
		edges = append(edges, resource.EdgeProperties)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ResourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpool {
		edges = append(edges, resource.EdgePool)
	}
	if m.clearednested_pool {
		edges = append(edges, resource.EdgeNestedPool)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case resource.EdgePool:
		return m.clearedpool
	case resource.EdgeNestedPool:
		return m.clearednested_pool
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ResourceMutation) ClearEdge(name string) error {
	switch name {
	case resource.EdgePool:
		m.ClearPool()
		return nil
	case resource.EdgeNestedPool:
		m.ClearNestedPool()
		return nil
	}
	return fmt.Errorf("unknown Resource unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ResourceMutation) ResetEdge(name string) error {
	switch name {
	case resource.EdgePool:
		m.ResetPool()
		return nil
	case resource.EdgeProperties:
		m.ResetProperties()
		return nil
	case resource.EdgeNestedPool:
		m.ResetNestedPool()
		return nil
	}
	return fmt.Errorf("unknown Resource edge %s", name)
}

// ResourcePoolMutation represents an operation that mutate the ResourcePools
// nodes in the graph.
type ResourcePoolMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	name                         *string
	description                  *string
	pool_type                    *resourcepool.PoolType
	dealocation_safety_period    *int
	adddealocation_safety_period *int
	clearedFields                map[string]struct{}
	resource_type                *int
	clearedresource_type         bool
	tags                         map[int]struct{}
	removedtags                  map[int]struct{}
	claims                       map[int]struct{}
	removedclaims                map[int]struct{}
	allocation_strategy          *int
	clearedallocation_strategy   bool
	parent_resource              *int
	clearedparent_resource       bool
	done                         bool
	oldValue                     func(context.Context) (*ResourcePool, error)
}

var _ ent.Mutation = (*ResourcePoolMutation)(nil)

// resourcepoolOption allows to manage the mutation configuration using functional options.
type resourcepoolOption func(*ResourcePoolMutation)

// newResourcePoolMutation creates new mutation for $n.Name.
func newResourcePoolMutation(c config, op Op, opts ...resourcepoolOption) *ResourcePoolMutation {
	m := &ResourcePoolMutation{
		config:        c,
		op:            op,
		typ:           TypeResourcePool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourcePoolID sets the id field of the mutation.
func withResourcePoolID(id int) resourcepoolOption {
	return func(m *ResourcePoolMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourcePool
		)
		m.oldValue = func(ctx context.Context) (*ResourcePool, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourcePool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourcePool sets the old ResourcePool of the mutation.
func withResourcePool(node *ResourcePool) resourcepoolOption {
	return func(m *ResourcePoolMutation) {
		m.oldValue = func(context.Context) (*ResourcePool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourcePoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourcePoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ResourcePoolMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ResourcePoolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ResourcePoolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ResourcePool.
// If the ResourcePool object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourcePoolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ResourcePoolMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the description field.
func (m *ResourcePoolMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *ResourcePoolMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the ResourcePool.
// If the ResourcePool object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourcePoolMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *ResourcePoolMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[resourcepool.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *ResourcePoolMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[resourcepool.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *ResourcePoolMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, resourcepool.FieldDescription)
}

// SetPoolType sets the pool_type field.
func (m *ResourcePoolMutation) SetPoolType(rt resourcepool.PoolType) {
	m.pool_type = &rt
}

// PoolType returns the pool_type value in the mutation.
func (m *ResourcePoolMutation) PoolType() (r resourcepool.PoolType, exists bool) {
	v := m.pool_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPoolType returns the old pool_type value of the ResourcePool.
// If the ResourcePool object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourcePoolMutation) OldPoolType(ctx context.Context) (v resourcepool.PoolType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPoolType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPoolType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoolType: %w", err)
	}
	return oldValue.PoolType, nil
}

// ResetPoolType reset all changes of the "pool_type" field.
func (m *ResourcePoolMutation) ResetPoolType() {
	m.pool_type = nil
}

// SetDealocationSafetyPeriod sets the dealocation_safety_period field.
func (m *ResourcePoolMutation) SetDealocationSafetyPeriod(i int) {
	m.dealocation_safety_period = &i
	m.adddealocation_safety_period = nil
}

// DealocationSafetyPeriod returns the dealocation_safety_period value in the mutation.
func (m *ResourcePoolMutation) DealocationSafetyPeriod() (r int, exists bool) {
	v := m.dealocation_safety_period
	if v == nil {
		return
	}
	return *v, true
}

// OldDealocationSafetyPeriod returns the old dealocation_safety_period value of the ResourcePool.
// If the ResourcePool object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourcePoolMutation) OldDealocationSafetyPeriod(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDealocationSafetyPeriod is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDealocationSafetyPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDealocationSafetyPeriod: %w", err)
	}
	return oldValue.DealocationSafetyPeriod, nil
}

// AddDealocationSafetyPeriod adds i to dealocation_safety_period.
func (m *ResourcePoolMutation) AddDealocationSafetyPeriod(i int) {
	if m.adddealocation_safety_period != nil {
		*m.adddealocation_safety_period += i
	} else {
		m.adddealocation_safety_period = &i
	}
}

// AddedDealocationSafetyPeriod returns the value that was added to the dealocation_safety_period field in this mutation.
func (m *ResourcePoolMutation) AddedDealocationSafetyPeriod() (r int, exists bool) {
	v := m.adddealocation_safety_period
	if v == nil {
		return
	}
	return *v, true
}

// ResetDealocationSafetyPeriod reset all changes of the "dealocation_safety_period" field.
func (m *ResourcePoolMutation) ResetDealocationSafetyPeriod() {
	m.dealocation_safety_period = nil
	m.adddealocation_safety_period = nil
}

// SetResourceTypeID sets the resource_type edge to ResourceType by id.
func (m *ResourcePoolMutation) SetResourceTypeID(id int) {
	m.resource_type = &id
}

// ClearResourceType clears the resource_type edge to ResourceType.
func (m *ResourcePoolMutation) ClearResourceType() {
	m.clearedresource_type = true
}

// ResourceTypeCleared returns if the edge resource_type was cleared.
func (m *ResourcePoolMutation) ResourceTypeCleared() bool {
	return m.clearedresource_type
}

// ResourceTypeID returns the resource_type id in the mutation.
func (m *ResourcePoolMutation) ResourceTypeID() (id int, exists bool) {
	if m.resource_type != nil {
		return *m.resource_type, true
	}
	return
}

// ResourceTypeIDs returns the resource_type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ResourceTypeID instead. It exists only for internal usage by the builders.
func (m *ResourcePoolMutation) ResourceTypeIDs() (ids []int) {
	if id := m.resource_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResourceType reset all changes of the "resource_type" edge.
func (m *ResourcePoolMutation) ResetResourceType() {
	m.resource_type = nil
	m.clearedresource_type = false
}

// AddTagIDs adds the tags edge to Tag by ids.
func (m *ResourcePoolMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// RemoveTagIDs removes the tags edge to Tag by ids.
func (m *ResourcePoolMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed ids of tags.
func (m *ResourcePoolMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the tags ids in the mutation.
func (m *ResourcePoolMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags reset all changes of the "tags" edge.
func (m *ResourcePoolMutation) ResetTags() {
	m.tags = nil
	m.removedtags = nil
}

// AddClaimIDs adds the claims edge to Resource by ids.
func (m *ResourcePoolMutation) AddClaimIDs(ids ...int) {
	if m.claims == nil {
		m.claims = make(map[int]struct{})
	}
	for i := range ids {
		m.claims[ids[i]] = struct{}{}
	}
}

// RemoveClaimIDs removes the claims edge to Resource by ids.
func (m *ResourcePoolMutation) RemoveClaimIDs(ids ...int) {
	if m.removedclaims == nil {
		m.removedclaims = make(map[int]struct{})
	}
	for i := range ids {
		m.removedclaims[ids[i]] = struct{}{}
	}
}

// RemovedClaims returns the removed ids of claims.
func (m *ResourcePoolMutation) RemovedClaimsIDs() (ids []int) {
	for id := range m.removedclaims {
		ids = append(ids, id)
	}
	return
}

// ClaimsIDs returns the claims ids in the mutation.
func (m *ResourcePoolMutation) ClaimsIDs() (ids []int) {
	for id := range m.claims {
		ids = append(ids, id)
	}
	return
}

// ResetClaims reset all changes of the "claims" edge.
func (m *ResourcePoolMutation) ResetClaims() {
	m.claims = nil
	m.removedclaims = nil
}

// SetAllocationStrategyID sets the allocation_strategy edge to AllocationStrategy by id.
func (m *ResourcePoolMutation) SetAllocationStrategyID(id int) {
	m.allocation_strategy = &id
}

// ClearAllocationStrategy clears the allocation_strategy edge to AllocationStrategy.
func (m *ResourcePoolMutation) ClearAllocationStrategy() {
	m.clearedallocation_strategy = true
}

// AllocationStrategyCleared returns if the edge allocation_strategy was cleared.
func (m *ResourcePoolMutation) AllocationStrategyCleared() bool {
	return m.clearedallocation_strategy
}

// AllocationStrategyID returns the allocation_strategy id in the mutation.
func (m *ResourcePoolMutation) AllocationStrategyID() (id int, exists bool) {
	if m.allocation_strategy != nil {
		return *m.allocation_strategy, true
	}
	return
}

// AllocationStrategyIDs returns the allocation_strategy ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AllocationStrategyID instead. It exists only for internal usage by the builders.
func (m *ResourcePoolMutation) AllocationStrategyIDs() (ids []int) {
	if id := m.allocation_strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAllocationStrategy reset all changes of the "allocation_strategy" edge.
func (m *ResourcePoolMutation) ResetAllocationStrategy() {
	m.allocation_strategy = nil
	m.clearedallocation_strategy = false
}

// SetParentResourceID sets the parent_resource edge to Resource by id.
func (m *ResourcePoolMutation) SetParentResourceID(id int) {
	m.parent_resource = &id
}

// ClearParentResource clears the parent_resource edge to Resource.
func (m *ResourcePoolMutation) ClearParentResource() {
	m.clearedparent_resource = true
}

// ParentResourceCleared returns if the edge parent_resource was cleared.
func (m *ResourcePoolMutation) ParentResourceCleared() bool {
	return m.clearedparent_resource
}

// ParentResourceID returns the parent_resource id in the mutation.
func (m *ResourcePoolMutation) ParentResourceID() (id int, exists bool) {
	if m.parent_resource != nil {
		return *m.parent_resource, true
	}
	return
}

// ParentResourceIDs returns the parent_resource ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParentResourceID instead. It exists only for internal usage by the builders.
func (m *ResourcePoolMutation) ParentResourceIDs() (ids []int) {
	if id := m.parent_resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParentResource reset all changes of the "parent_resource" edge.
func (m *ResourcePoolMutation) ResetParentResource() {
	m.parent_resource = nil
	m.clearedparent_resource = false
}

// Op returns the operation name.
func (m *ResourcePoolMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ResourcePool).
func (m *ResourcePoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ResourcePoolMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, resourcepool.FieldName)
	}
	if m.description != nil {
		fields = append(fields, resourcepool.FieldDescription)
	}
	if m.pool_type != nil {
		fields = append(fields, resourcepool.FieldPoolType)
	}
	if m.dealocation_safety_period != nil {
		fields = append(fields, resourcepool.FieldDealocationSafetyPeriod)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ResourcePoolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourcepool.FieldName:
		return m.Name()
	case resourcepool.FieldDescription:
		return m.Description()
	case resourcepool.FieldPoolType:
		return m.PoolType()
	case resourcepool.FieldDealocationSafetyPeriod:
		return m.DealocationSafetyPeriod()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ResourcePoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourcepool.FieldName:
		return m.OldName(ctx)
	case resourcepool.FieldDescription:
		return m.OldDescription(ctx)
	case resourcepool.FieldPoolType:
		return m.OldPoolType(ctx)
	case resourcepool.FieldDealocationSafetyPeriod:
		return m.OldDealocationSafetyPeriod(ctx)
	}
	return nil, fmt.Errorf("unknown ResourcePool field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResourcePoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourcepool.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case resourcepool.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case resourcepool.FieldPoolType:
		v, ok := value.(resourcepool.PoolType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoolType(v)
		return nil
	case resourcepool.FieldDealocationSafetyPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDealocationSafetyPeriod(v)
		return nil
	}
	return fmt.Errorf("unknown ResourcePool field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ResourcePoolMutation) AddedFields() []string {
	var fields []string
	if m.adddealocation_safety_period != nil {
		fields = append(fields, resourcepool.FieldDealocationSafetyPeriod)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ResourcePoolMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resourcepool.FieldDealocationSafetyPeriod:
		return m.AddedDealocationSafetyPeriod()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResourcePoolMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resourcepool.FieldDealocationSafetyPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDealocationSafetyPeriod(v)
		return nil
	}
	return fmt.Errorf("unknown ResourcePool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ResourcePoolMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resourcepool.FieldDescription) {
		fields = append(fields, resourcepool.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ResourcePoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourcePoolMutation) ClearField(name string) error {
	switch name {
	case resourcepool.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ResourcePool nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ResourcePoolMutation) ResetField(name string) error {
	switch name {
	case resourcepool.FieldName:
		m.ResetName()
		return nil
	case resourcepool.FieldDescription:
		m.ResetDescription()
		return nil
	case resourcepool.FieldPoolType:
		m.ResetPoolType()
		return nil
	case resourcepool.FieldDealocationSafetyPeriod:
		m.ResetDealocationSafetyPeriod()
		return nil
	}
	return fmt.Errorf("unknown ResourcePool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ResourcePoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.resource_type != nil {
		edges = append(edges, resourcepool.EdgeResourceType)
	}
	if m.tags != nil {
		edges = append(edges, resourcepool.EdgeTags)
	}
	if m.claims != nil {
		edges = append(edges, resourcepool.EdgeClaims)
	}
	if m.allocation_strategy != nil {
		edges = append(edges, resourcepool.EdgeAllocationStrategy)
	}
	if m.parent_resource != nil {
		edges = append(edges, resourcepool.EdgeParentResource)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ResourcePoolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resourcepool.EdgeResourceType:
		if id := m.resource_type; id != nil {
			return []ent.Value{*id}
		}
	case resourcepool.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case resourcepool.EdgeClaims:
		ids := make([]ent.Value, 0, len(m.claims))
		for id := range m.claims {
			ids = append(ids, id)
		}
		return ids
	case resourcepool.EdgeAllocationStrategy:
		if id := m.allocation_strategy; id != nil {
			return []ent.Value{*id}
		}
	case resourcepool.EdgeParentResource:
		if id := m.parent_resource; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ResourcePoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtags != nil {
		edges = append(edges, resourcepool.EdgeTags)
	}
	if m.removedclaims != nil {
		edges = append(edges, resourcepool.EdgeClaims)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ResourcePoolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resourcepool.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case resourcepool.EdgeClaims:
		ids := make([]ent.Value, 0, len(m.removedclaims))
		for id := range m.removedclaims {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ResourcePoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedresource_type {
		edges = append(edges, resourcepool.EdgeResourceType)
	}
	if m.clearedallocation_strategy {
		edges = append(edges, resourcepool.EdgeAllocationStrategy)
	}
	if m.clearedparent_resource {
		edges = append(edges, resourcepool.EdgeParentResource)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ResourcePoolMutation) EdgeCleared(name string) bool {
	switch name {
	case resourcepool.EdgeResourceType:
		return m.clearedresource_type
	case resourcepool.EdgeAllocationStrategy:
		return m.clearedallocation_strategy
	case resourcepool.EdgeParentResource:
		return m.clearedparent_resource
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ResourcePoolMutation) ClearEdge(name string) error {
	switch name {
	case resourcepool.EdgeResourceType:
		m.ClearResourceType()
		return nil
	case resourcepool.EdgeAllocationStrategy:
		m.ClearAllocationStrategy()
		return nil
	case resourcepool.EdgeParentResource:
		m.ClearParentResource()
		return nil
	}
	return fmt.Errorf("unknown ResourcePool unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ResourcePoolMutation) ResetEdge(name string) error {
	switch name {
	case resourcepool.EdgeResourceType:
		m.ResetResourceType()
		return nil
	case resourcepool.EdgeTags:
		m.ResetTags()
		return nil
	case resourcepool.EdgeClaims:
		m.ResetClaims()
		return nil
	case resourcepool.EdgeAllocationStrategy:
		m.ResetAllocationStrategy()
		return nil
	case resourcepool.EdgeParentResource:
		m.ResetParentResource()
		return nil
	}
	return fmt.Errorf("unknown ResourcePool edge %s", name)
}

// ResourceTypeMutation represents an operation that mutate the ResourceTypes
// nodes in the graph.
type ResourceTypeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	name                  *string
	clearedFields         map[string]struct{}
	property_types        map[int]struct{}
	removedproperty_types map[int]struct{}
	pools                 map[int]struct{}
	removedpools          map[int]struct{}
	done                  bool
	oldValue              func(context.Context) (*ResourceType, error)
}

var _ ent.Mutation = (*ResourceTypeMutation)(nil)

// resourcetypeOption allows to manage the mutation configuration using functional options.
type resourcetypeOption func(*ResourceTypeMutation)

// newResourceTypeMutation creates new mutation for $n.Name.
func newResourceTypeMutation(c config, op Op, opts ...resourcetypeOption) *ResourceTypeMutation {
	m := &ResourceTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeResourceType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceTypeID sets the id field of the mutation.
func withResourceTypeID(id int) resourcetypeOption {
	return func(m *ResourceTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ResourceType
		)
		m.oldValue = func(ctx context.Context) (*ResourceType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResourceType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResourceType sets the old ResourceType of the mutation.
func withResourceType(node *ResourceType) resourcetypeOption {
	return func(m *ResourceTypeMutation) {
		m.oldValue = func(context.Context) (*ResourceType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ResourceTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ResourceTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ResourceTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ResourceType.
// If the ResourceType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ResourceTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ResourceTypeMutation) ResetName() {
	m.name = nil
}

// AddPropertyTypeIDs adds the property_types edge to PropertyType by ids.
func (m *ResourceTypeMutation) AddPropertyTypeIDs(ids ...int) {
	if m.property_types == nil {
		m.property_types = make(map[int]struct{})
	}
	for i := range ids {
		m.property_types[ids[i]] = struct{}{}
	}
}

// RemovePropertyTypeIDs removes the property_types edge to PropertyType by ids.
func (m *ResourceTypeMutation) RemovePropertyTypeIDs(ids ...int) {
	if m.removedproperty_types == nil {
		m.removedproperty_types = make(map[int]struct{})
	}
	for i := range ids {
		m.removedproperty_types[ids[i]] = struct{}{}
	}
}

// RemovedPropertyTypes returns the removed ids of property_types.
func (m *ResourceTypeMutation) RemovedPropertyTypesIDs() (ids []int) {
	for id := range m.removedproperty_types {
		ids = append(ids, id)
	}
	return
}

// PropertyTypesIDs returns the property_types ids in the mutation.
func (m *ResourceTypeMutation) PropertyTypesIDs() (ids []int) {
	for id := range m.property_types {
		ids = append(ids, id)
	}
	return
}

// ResetPropertyTypes reset all changes of the "property_types" edge.
func (m *ResourceTypeMutation) ResetPropertyTypes() {
	m.property_types = nil
	m.removedproperty_types = nil
}

// AddPoolIDs adds the pools edge to ResourcePool by ids.
func (m *ResourceTypeMutation) AddPoolIDs(ids ...int) {
	if m.pools == nil {
		m.pools = make(map[int]struct{})
	}
	for i := range ids {
		m.pools[ids[i]] = struct{}{}
	}
}

// RemovePoolIDs removes the pools edge to ResourcePool by ids.
func (m *ResourceTypeMutation) RemovePoolIDs(ids ...int) {
	if m.removedpools == nil {
		m.removedpools = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpools[ids[i]] = struct{}{}
	}
}

// RemovedPools returns the removed ids of pools.
func (m *ResourceTypeMutation) RemovedPoolsIDs() (ids []int) {
	for id := range m.removedpools {
		ids = append(ids, id)
	}
	return
}

// PoolsIDs returns the pools ids in the mutation.
func (m *ResourceTypeMutation) PoolsIDs() (ids []int) {
	for id := range m.pools {
		ids = append(ids, id)
	}
	return
}

// ResetPools reset all changes of the "pools" edge.
func (m *ResourceTypeMutation) ResetPools() {
	m.pools = nil
	m.removedpools = nil
}

// Op returns the operation name.
func (m *ResourceTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ResourceType).
func (m *ResourceTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ResourceTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, resourcetype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ResourceTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resourcetype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ResourceTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resourcetype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ResourceType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResourceTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resourcetype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ResourceType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ResourceTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ResourceTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ResourceTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResourceType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ResourceTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ResourceTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ResourceType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ResourceTypeMutation) ResetField(name string) error {
	switch name {
	case resourcetype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ResourceType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ResourceTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.property_types != nil {
		edges = append(edges, resourcetype.EdgePropertyTypes)
	}
	if m.pools != nil {
		edges = append(edges, resourcetype.EdgePools)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ResourceTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resourcetype.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.property_types))
		for id := range m.property_types {
			ids = append(ids, id)
		}
		return ids
	case resourcetype.EdgePools:
		ids := make([]ent.Value, 0, len(m.pools))
		for id := range m.pools {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ResourceTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproperty_types != nil {
		edges = append(edges, resourcetype.EdgePropertyTypes)
	}
	if m.removedpools != nil {
		edges = append(edges, resourcetype.EdgePools)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ResourceTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resourcetype.EdgePropertyTypes:
		ids := make([]ent.Value, 0, len(m.removedproperty_types))
		for id := range m.removedproperty_types {
			ids = append(ids, id)
		}
		return ids
	case resourcetype.EdgePools:
		ids := make([]ent.Value, 0, len(m.removedpools))
		for id := range m.removedpools {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ResourceTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ResourceTypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ResourceTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ResourceType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ResourceTypeMutation) ResetEdge(name string) error {
	switch name {
	case resourcetype.EdgePropertyTypes:
		m.ResetPropertyTypes()
		return nil
	case resourcetype.EdgePools:
		m.ResetPools()
		return nil
	}
	return fmt.Errorf("unknown ResourceType edge %s", name)
}

// TagMutation represents an operation that mutate the Tags
// nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *int
	tag           *string
	clearedFields map[string]struct{}
	pools         map[int]struct{}
	removedpools  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Tag, error)
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows to manage the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for $n.Name.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the id field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTag sets the tag field.
func (m *TagMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the tag value in the mutation.
func (m *TagMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old tag value of the Tag.
// If the Tag object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TagMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTag is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ResetTag reset all changes of the "tag" field.
func (m *TagMutation) ResetTag() {
	m.tag = nil
}

// AddPoolIDs adds the pools edge to ResourcePool by ids.
func (m *TagMutation) AddPoolIDs(ids ...int) {
	if m.pools == nil {
		m.pools = make(map[int]struct{})
	}
	for i := range ids {
		m.pools[ids[i]] = struct{}{}
	}
}

// RemovePoolIDs removes the pools edge to ResourcePool by ids.
func (m *TagMutation) RemovePoolIDs(ids ...int) {
	if m.removedpools == nil {
		m.removedpools = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpools[ids[i]] = struct{}{}
	}
}

// RemovedPools returns the removed ids of pools.
func (m *TagMutation) RemovedPoolsIDs() (ids []int) {
	for id := range m.removedpools {
		ids = append(ids, id)
	}
	return
}

// PoolsIDs returns the pools ids in the mutation.
func (m *TagMutation) PoolsIDs() (ids []int) {
	for id := range m.pools {
		ids = append(ids, id)
	}
	return
}

// ResetPools reset all changes of the "pools" edge.
func (m *TagMutation) ResetPools() {
	m.pools = nil
	m.removedpools = nil
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tag != nil {
		fields = append(fields, tag.FieldTag)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldTag:
		return m.Tag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldTag:
		return m.OldTag(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.pools != nil {
		edges = append(edges, tag.EdgePools)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgePools:
		ids := make([]ent.Value, 0, len(m.pools))
		for id := range m.pools {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpools != nil {
		edges = append(edges, tag.EdgePools)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgePools:
		ids := make([]ent.Value, 0, len(m.removedpools))
		for id := range m.removedpools {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgePools:
		m.ResetPools()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}
